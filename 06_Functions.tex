\chapter{Funktionen}
\label{chp:Funcs}
\epigraph{
	Before software can be reusable it first has to be usable.
}{Ralph Johnson}

Viele Aufgaben wiederholen sich oder lassen sich verallgemeinern. Folgender Code berechnet beispielsweise den Wert von Eulers Zahl, also $\exp(1)$, kann aber auch dazu verwendet werden, andere Potenzen von $e$ zu finden:

\begin{codebox}[Beispiel: Exponentialfunktion]
\begin{minted}[linenos]{python}
x0           = 1.0
x            = 1.0
denominator  = 1.0
EulersNumber = 1.0
iterations   = 10

for k in range(1, iterations) :
    x            *= x0
    denominator  *= k
    EulersNumber += x / denominator

print ("exp(", x0, ") is approximately ", EulersNumber, sep = "")
\end{minted}
\end{codebox}

Nun ist es zwar schön, eine solche allgemeine Rechenvorschrift zu haben; wir müssen nur den Wert für \inPy{x0} in der ersten Zeile austauschen, und erhalten ein neues Ergebnis. Wollen wir aber an mehreren Stellen die Exponentialfunktion verwenden, so müssten wir diesen Code jedes Mal kopieren und neu einfügen. Schlimmer noch: sollte uns auffallen, dass wir im obigen Code einen Fehler gemacht haben, so müssen wir diesen \emph{für jede Kopie separat} ausmerzen. Und selbst, wenn wir auf Anhieb perfekt gearbeitet haben, \enquote{belegt} unser Code jetzt \ua die Symbole \inPy{x} und \inPy{x0}. Projekte, die diesen Code verwenden wollen, müssen also andere Namen finden.

Natürlich wissen Sie, dass es im Modul \inPy{math} die \emph{Funktion} \inPy{math.exp} gibt, die ebenfalls die Exponentialfunktion berechnet, aber ohne all diese lästigen Nebeneffekte auskommt. Hier sollen Sie lernen, wie dies möglich ist, und wie Sie solche Funktionen selbst erstellen.

\section{Grundlagen}
Funktionen sind \enquote{abgetrennte Codebereiche}, die unabhängig vom restlichen Code ausgeführt werden. In eine Funktion können Argumente (oft auch Parameter genannt) eingespeist werden (man spricht von \emph{übergeben}), und ein Ergebnis wird von  \emph{zurückgegeben}. Zur Berechnung dieses Ergebnisses wird normaler Code ausgeführt; dieser verhält sich aber \enquote{wie in einer Box}, \ie verwendet seine eigenen, \emph{lokalen} Variablen. Diese können dieselben Namen tragen wie Variablen an anderen Stellen Ihres Programms; nichts desto trotz sind die Variablen in einer Funktion unabhängig vom restlichen Code. (Ebenso, wie es zwei Menschen mit dem Namen \emph{Theophrastus} geben kann\footnote{citation needed}, die aber dennoch zwei getrennte Personen sind, können also auch zwei Variablen mit demselben Namen vorliegen, ohne \emph{dieselbe} Variable zu sein.)

Ein solcher Codebereich wird eingeleitet durch eine \inPy{def}-Zeile und wird durch Einrückung vom restlichen Code abgetrennt, ähnlich, wie wir das schon von \inPy{if}-Blöcken und \inPy{for}-Schleifen kennen:

\begin{codebox}[Syntax: Funktionen]
\begin{minted}{python}
def Funktionsname (Parameterliste) :
    normaler Code
    ...
    return Ergebnis
\end{minted}
\end{codebox}

Mit \inPy{Parameterliste} ist eine durch Kommata getrennte Liste von Variablennamen. Über diese Variablennamen werden \enquote{Informationen von außen in die Funktion eingeschleust} (Übergabe von Werten). Verstehen Sie die Parameterliste als einen Punkt, an dem Variablen angelegt werden. Die Werte dieser Variablen werden beim Aufruf der Funktion festgelegt, und können in der Funktion wie normale Variablen verwendet werden. Eine Parameterliste kann auch leer sein. In dem Fall müssen aber immer noch  leere Klammern () gesetzt werden.

Wie besprochen steht innerhalb einer Funktion Code, wie sie ihn schon kennen bzw. noch kennenlernen werden. Alle Mittel, die Sie bisher kennengelernt haben auch auch solche, wie wir sie im Weiteren noch besprechen, können auch innerhalb von Funktionen verwendet werden.

In der Regel soll eine Funktion ein Ergebnis berechnen, \eg den Wert der Exponentialfunktion. Dieses Ergebnis wird mit dem Befehl \inPy{return} zurück an das Hauptprogramm geschickt und zugleich die Funktion verlassen. Aller Code in der Funktion, der hinter \inPy{return} steht, wird also ignoriert. Eine Funktion darf durchaus mehrere \inPy{return}-Anweisungen haben. Sinnvoll kann das sein, wenn eine Fallunterscheidung gemacht wird (\eg mit \inPy{if}). Genauso ist es auch zulässig, überhaupt keine \inPy{return}-Anweisung zu benutzen. Stellen Sie sich zum Beispiel eine Funktion vor, die lediglich eine formatierte Ausgabe auf dem Bildschirm bewirken soll. Hier wird kein Ergebnis berechnet. Entsprechend kann auch die \inPy{return}-Anweisung entfallen.

\emph{Aufgerufen} (\ie ausgeführt) wird die Funktion durch Nennung ihres Namens. In Klammern dahinter werden die Werte aufgeführt, die über die Parameterliste an die Funktion übergeben werden sollen. Für jede Variable der Parameterliste muss auch ein Wert angegeben werden. Ist die Parameterliste leer, so müssen dennoch leere Klammern () beim Funktionsaufruf stehen.

Ein Funktionsaufruf macht also mehrere Dinge:
\begin{itemize}
\item Eine \emph{Kopie} der Werte in der Parameterliste wird an die Funktion übergeben
\item Die Programmausführung springt in die Funktion
\item Nach Ende der Funktion wird das Programm an der ürsprünglichen Stelle fortgeführt.
\end{itemize}
Nach Ende des Funktionsaufrufs wird an der aufrufenden Stelle ein Wert erhalten (eben der Rückgabewert der Funktion). Dieser kann in einer Variablen gespeichert werden, oder an andere Funktionen weitergegeben werden.

\begin{codebox}[Beispiel: Exponentialfunktion als Funktion]
\begin{minted}[linenos]{python}
def expFunction(x0) :
    x           = 1.0
    denominator = 1.0
    result      = 1.0
    iterations  = 10
  
    for k in range(1, iterations) :
        x            *= x0
        denominator  *= k
        result += x / denominator
    
    return result

EulersNumber = expFunction(1.0)          # Aufruf, Speichern in Variable
print("Eulers Number is", EulersNumber)
print("e³ =", expFunction(3.0))          # Weitergabe an andere Funktion
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Exponentialfunktion als Funktion]
\begin{minted}{text}
Eulers Number is 2.7182815255731922
e³ = 20.063392857142855
\end{minted}
\end{cmdbox}

Wird kein Rückgabewert genannt, so weist Python automatisch den Pseudo-Rückgabewert \inPy{None} zu. Es handelt sich dabei um eine Konstante, die eben genau für die Abwesenheit eines Wertes steht, und sollte auch nicht mit dem Text \inPy{"None"} verwechselt werden.
\begin{codebox}[Beispiel: Funktion \enquote{ohne} Rückgabewert]
\begin{minted}[linenos]{python}
import math

def printBoxed(text, boxSize) :
    # Draws text in a box like:
    #
    # +-----------+
    # |   text    |
    # +-----------+
  
    lenText     = len(text)
    countSpaces = boxSize - lenText - 2        # 2 spaces for |borders|
    spacesLeft  = math.floor(countSpaces / 2)  # round down
    spacesRight = math.ceil (countSpaces / 2)  # round up
  
    print("+" +               (boxSize - 2) * "-"           + "+")
    print("|" + spacesLeft * " " + text + spacesRight * " " + "|")
    print("+" +               (boxSize - 2) * "-"           + "+")
  
reVal = printBoxed("Don't forget to be awesome!", 60)
print("The function returned:" , reVal)
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Funktion \enquote{ohne} Rückgabewert]
\begin{minted}{text}
+----------------------------------------------------------+
|               Don't forget to be awesome!                |
+----------------------------------------------------------+
The function returned: None
\end{minted}
\end{cmdbox}

Wie erwähnt wird die Ausführung der Funktion sofort beendet, sobald der Interpreter auf eine \inPy{return}-Anweisung stößt. Daher haben die Zeilen 4 und 7 im folgenden Beispiel keinerlei Auswirkung:
\begin{codebox}[Beispiel: Funktion mit mehreren \texttt{return}-Anweisungen]
\begin{minted}[linenos]{python}
def max (a, b) :
    if a > b :
        return a
        print("this line will never be executed")
    else :
        return b
        print("and neither will this one")

print(max(1, 2))
print(max(2, 1))
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Funktion mit mehreren \texttt{return}-Anweisungen]
\begin{minted}{text}
2
2
\end{minted}
\end{cmdbox}

Funktionen können auch mehrere Rückgabewerte haben. Diese werden dann durch Kommata getrennt bei \inPy{return} aufgeführt und vom Python-Interpreter automatisch zu einem \inPy{tuple} \enquote{gepackt}. An der aufrufenden Stelle kann dieser \inPy{tuple} auch wieder automatisch entpackt werden:
\begin{codebox}[Beispiel: Rückgabe eines \texttt{tuple}s]
\begin{minted}[linenos]{python}
def returnATuple () :
    return 1, 2, 3

fullTuple       = returnATuple()
one, two, three = returnATuple()

print(fullTuple)
print(one, two, three)
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Rückgabe eines \texttt{tuple}s]
\begin{minted}{text}
(1, 2, 3)
1 2 3
\end{minted}
\end{cmdbox}

In Zeile 2 könnte gleichermaßen auch stehen: \inPy{return (1, 2, 3)}. Der Effekt wäre exakt derselbe.

Wichtig ist, immer im Kopf zu behalten, dass die Variablen, die in einer Funktion benuzt werden, vom restlichen Programm unabhängig sind. Es darf also sich widersprechende Definitionen geben; die Definitionen gelten nur jeweils innerhalb einer Funktion:

\begin{codebox}[Beispiel: Gleiches Symbol{,} unterschiedliche Inhalte]
\begin{minted}[linenos]{python}
def func() :
    a = 7
    print("in func: a =", a)

a = 999
print("on module level: a =", a)
func()
print("on module level: a =", a)
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Gleiches Symbol{,} unterschiedliche Inhalte]
\begin{minted}{text}
on module level: a = 999
in func: a = 7
on module level: a = 999
\end{minted}
\end{cmdbox}

Das \inPy{a} in \inPy{func} erhält also seine eigene Speicherstelle. Je nach Kontext sucht der Python-Interpreter aus, ob die \inPy{func}-Speicherstelle oder die Modul-Level-Speicherstelle mit dem Symbol \inPy{a} gemeint ist.

In Python dürfen Funktionen auch ineinander verschachtelt werden. Dies kann zum Beispiel nütlich werden, wenn eine Funktion aus mehreren, sich wiederholenden Teilaufgaben besteht, die sonst nirgendwo gebraucht werden:

\begin{codebox}[Beispiel: Verschachtelte Funktionen]
\begin{minted}[linenos]{python}
def veryComplexTask(listOfObjects) :
    def subTask(element) :
        # ...
        pass
    
    for element in listOfObjects :
        subTask(element)
  
    # ...
\end{minted}
\end{codebox}

Andere Gründe, Funktionen ineinander zu verschachteln werden in Kapitel \ref{chp:Decorators} gezeigt.

\section{By-Value- und By-Reference-Übergabe}
Wir hatten festgestellt, dass die Variablen, die wir in einer Funktion verwenden, vom restlichen Code abgetrennt sind. Wie aber verhält es sich mit den Parametern?

Sehen wir uns dazu folgenden Code an:
\begin{codebox}[Beispiel: Übergabe von Referenz by Value]
\begin{minted}[linenos]{python}
def Vercingetorix(data) :
    data.append(1)
    data = data + [2]
    print("in Vercingetorix: data =", data)

data = []
Vercingetorix(data)
print("on module level: data =", data)
\end{minted}
\end{codebox}
Oben wurde bereits gesagt, dass bei einem Funktionsaufruf eine \emph{Kopie} des Originalobjekts (hier also \inPy{data}) an die Funktion übergeben wird. Dann würden wir also erwarten, dass in Zeile 8 die Liste \inPy{data} wieder unverändert als leere Liste vorliegt. Kurioserweise lautet die Ausgabe aber:

\begin{cmdbox}[Ausgabe: Übergabe von Referenz by Value]
\begin{minted}{text}
in Vercingetorix: data = [1, 2]
on module level: data = [1]
\end{minted}
\end{cmdbox}

Wie lässt sich dies erklären?

In Abschnitt \ref{sec:MemoryModel} hatten wir uns klar gemacht, dass Variablen in Python in Wirklichkeit primär die \emph{Adressen} der eigentlichen Information speichert. Diese Adresse wird auch als Kopie übergeben. In Zeile 2 erteilen wir nun den Befehl, an die Liste an der Stelle \inPy{data} die Zahl 1 anzuhängen. Die Liste wird dadurch im Speicher nicht verschoben; daher sehen wir später in Zeile 8 das Ergebnis dieser Änderung.

In Zeile 3 dagegen wird eine \emph{neue} Liste berechnet (nämlich \inPy{[1, 2]}). Diese neue Liste wird an einer eigenen Speicherstelle angelegt, überschreibt also nicht die alten Daten an der Adresse \inPy{data}. Wir speichern in Zeile 3 die Adresse in der \emph{lokalen} Variablen \inPy{data}. Das bedeutet, die Funtion \inPy{Vercingetorix} weiß nun nicht mehr, wo die Original-Liste sich befindet, sondern kann nur noch die Liste \inPy{[1 ,2]} ausgeben -- und dies geschieht auch in Zeile 4. Die ursprüngliche Liste besteht aber weiterhin. Wo diese sich befindet, ist immer noch in der Variablen \inPy{data} des Modul-Levels gespeichert. Wir sehen daher in Zeile 8 das Ergebnis von \inPy{append} (da dies die Adresse von \inPy{data} nicht verändert hat), nicht aber das Ergebnis von \inPy{data = data + [2]} (da hierfür eine neue Liste angelegt wurde).

\begin{tcolorbox}[title=Speicherbild]
\begin{center}
\begin{tikzpicture}
  [ 
    cell/.style={text width=8mm,
      text height=4mm, draw=black, inner sep=1mm},
    ld/.style={draw=blue,shorten >=2pt,->}
  ]
  \node (a1) at (0,4) [cell] {\ttfamily ...};
  \node (a2) at (1,4) [cell] {\ttfamily  []};
  \node (a3) at (2,4) [cell] {\ttfamily ...};
  \node (a4) at (3,4) [cell] {\ttfamily ...};
  \node (a5) at (4,4) [cell] {\ttfamily ...};
  \node (a6) at (5,4) [cell] {\ttfamily ...};

  \node (b1) at (0,2) [cell] {\ttfamily ...};
  \node (b2) at (1,2) [cell] {\ttfamily [1]};
  \node (b3) at (2,2) [cell] {\ttfamily ...};
  \node (b4) at (3,2) [cell] {\ttfamily ...};
  \node (b5) at (4,2) [cell] {\ttfamily ...};
  \node (b6) at (5,2) [cell] {\ttfamily ...};

  \node (c1) at (0,0) [cell] {\ttfamily ...};
  \node (c2) at (1,0) [cell] {\ttfamily [1]};
  \node (c3) at (2,0) [cell] {\ttfamily ...};
  \node (c4) at (3,0) [cell] {\ttfamily ...};
  \node (c5) at (4,0) [cell] {\ttfamily ...};
  \node (c6) at (5,0) [cell] {\ttfamily [1,2]};

%  \node (labelMem) at (8,  1) {Symbole im Code};
%  \node (labelMem) at (8,  0) {Werte im Speicher};
%  \node (labelMem) at (8, -1) {Adressen};
  
  \node (A1) [below=2mm of a1]             {\tiny 0x27ff};
  \node (A2) [below=2mm of a2, color=teal] {\tiny 0x2800};
  \node (A3) [below=2mm of a3]             {\tiny 0x2801};
  \node (A4) [below=2mm of a4]             {\tiny 0x2802};
  \node (A5) [below=2mm of a5]             {\tiny 0x2803};
  \node (A6) [below=2mm of a6]             {\tiny 0x2804};
  
  \node (B1) [below=2mm of b1]             {\tiny 0x27ff};
  \node (B2) [below=2mm of b2, color=teal] {\tiny 0x2800};
  \node (B3) [below=2mm of b3]             {\tiny 0x2801};
  \node (B4) [below=2mm of b4]             {\tiny 0x2802};
  \node (B5) [below=2mm of b5]             {\tiny 0x2803};
  \node (B6) [below=2mm of b6]             {\tiny 0x2804};
  
  \node (C1) [below=2mm of c1]             {\tiny 0x27ff};
  \node (C2) [below=2mm of c2, color=teal] {\tiny 0x2800};
  \node (C3) [below=2mm of c3]             {\tiny 0x2801};
  \node (C4) [below=2mm of c4]             {\tiny 0x2802};
  \node (C5) [below=2mm of c5]             {\tiny 0x2803};
  \node (C6) [below=2mm of c6, color=blue] {\tiny 0x2804};

  \node (main1) [below=0mm of A2, color=teal] {\scriptsize Adresse von \texttt{data} in Modul-Level und in \texttt{Vercingetorx}};
  \node (main2) [below=0mm of B2, color=teal] {\scriptsize Adresse von \texttt{data} in Modul-Level und in \texttt{Vercingetorx}};
  \node (main3) [below=0mm of C2, color=teal] {\scriptsize Adr. von \texttt{data} in Modul-Level};
  \node (func)  [below=0mm of C6, color=blue] {\scriptsize Adr. von \texttt{data} in \texttt{Vercingetorix}};
  
  \draw [->] (a6.east)arc(120:-115:1.0);		%start angle: stop angle : radius  
  \node (step1) at (9,3) {\texttt{data.append(1)}};
  \draw [->] (b6.east)arc(120:-115:1.0);
  \node (step1) at (9,1) {\texttt{data = data + [2]}};
\end{tikzpicture}
\end{center}
\end{tcolorbox}


Durchdenken wir nun auch dieses Beispiel:
\begin{codebox}[Beispiel: Übergabe von Immutables]
\begin{minted}[linenos]{python}
def Vercingetorix(data) :
    data = 2
    print("in Vercingetorix: data =", data)

data = 1
Vercingetorix(data)
print("on module level: data =", data)
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Übergabe von Immutables]
\begin{minted}{text}
in Vercingetorix: data = 2
on module level: data = 1
\end{minted}
\end{cmdbox}

Wir erinnern uns, dass \inPy{1} ein Wert vom Typ \inPy{int} und damit \emph{immutable} ist. Der Wert an der Stelle \inPy{data} darf also nicht verändert werden. Wenn nun also Zeile 2 verlangt, den neuen Wert \inPy{2} \enquote{in \inPy{data}} zu speichern, so wird eine neue Speicherstelle angelegt, und deren Adresse in der Instanz \inPy{data} in \inPy{Vercingetorix} gespeichert.

\begin{hintbox}[Speicherstruktur von \texttt{list}s]
Die oben gezeigten Speicherbilder sind eine Vereinfachung der Realität. Wie erwähnt kann jede Zelle des Speichers nur ein einziges Byte fassen, also nicht einmal einen ganzen \inPy{int}-Wert. Stattdessen finden Sie dort einen \emph{descriptor}, also ein Datenpaket, das unter anderem aus einer Ganzzahl (Anzahl der Elemente in der Liste) und einem Pointer (tatsächlicher Speicherort des ersten Elements der Liste, also eine Adresse) enthält. Dadurch bleibt die Adresse \inPy{data} konstant, selbst wenn der Listeninhalt \enquote{umziehen} muss.

In systemnahen Sprachen wie C müssen Sie das mit im Auge behalten. Bei der Arbeit in Python dagegen können Sie sich weit mehr auf \enquote{das Große und Ganze} konzentrieren.
\end{hintbox}

\section{Scopes, \inPy{global}, \inPy{nonlocal}}
Bisher habe ich Ihnen verschwiegen, dass es möglich ist, innerhalb von Funktionen auf Variablen des Modullevels zuzugreifen. Dabei dürfen aber nur solche Operationen durchgeführt werden, die den Speicherort der Variablen nicht verändern. Auf Modulebene dagegen sind die Symbole in den Funktionen nie zugänglich.
Sehen Sie sich hierzu das folgende Beispiel an:
\begin{codebox}[Beispiel: lokale Variablen]
\begin{minted}[linenos]{python}
foo = ["foo"]

def foobar() :
    cat = "confused"      # lokale Variable
    print(foo)            # liest die Variable auf Modulebene
    foo.append("bar")     # schreibender Zugriff, keine Änderung der Adresse
    #foo = foo + ["baz"]  ! Fehler: Neue Adresse

foobar()

print(foo)
# print(cat)            ! Fehler: 'cat' ist Variable von foobar.
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: lokale Variablen]
\begin{minted}{text}
['foo']
['foo', 'bar']
\end{minted}
\end{cmdbox}

Man spricht hierbei von \emph{Scopes}: Jedes Symbol hat einen zugeordneten Bereich, in dem dieses Symbol gültig ist (in dem es \enquote{existiert}). Dieser Gültigkeitsbereich (Scope) reicht von dem Punkt, an dem das Symbol \emph{definiert} wird (\ie bei der ersten Wertzuweisung) bis zum \emph{Ende der aktuellen Einrückungsebene}. Die Variable \inPy{cat} des obigen Beispiels gehört also zum Scope der Funktion \inPy{foobar}, und darf damit nur in den Zeilen 4-7 benutzt werden. Ein Zugriff wie in Zeile 11 dagegen führt zu einem Fehler.

Die Variable \inPy{foo} dagegen existiert in allen Zeilen des Programms (1-11), da sie auf Modulebene definiert wurde. Der Scope der Funktion \inPy{foobar} ist vom Scope der Modulebene umschlossen, \emph{gehört also dazu}. Sie können auch sagen, \enquote{es ist nicht möglich, in Funktionen hineinzusehen, wohl aber aus ihnen heraus zu schauen}.

\begin{warnbox}[Zugriffe klar halten]
Sie können sich vermutlich jetzt schon vorstellen, dass es schwierig wird, den Überblick zu behalten, welche Variablen an welcher Stelle sichtbar sind, und wann ein Schreibzugriff zulässig ist. Das hier Gezeigte soll Sie daher auch nur dazu in die Lage versetzen, Codes von anderen Autoren zu lesen und korrekt zu interpretieren. Im Allgemeinen ist davon abzuraten, Konstruktionen zu programmieren, bei denen Variablen über Scope-Grenzen hinweg genutzt werden. Halten Sie sich am besten an den Leitsatz, dass Information nur über die Parameterliste in eine Funktion gelangt, und nur über den Rückgabewert aus dieser heraus kommt.
\end{warnbox}
\begin{hintbox}[Konstanten]
Ein Fall, in dem es sinnvoll sein kann, von diesem Leitsatz abzuweichen sind Naturkonstanten. Wenn Sie den Flug eines Balles durch die Luft modellieren, wollen Sie nicht in jeder Funktion die Graviationskonstante als Parameter mit übergeben. Es ist aber auch im allgemeinen keine gute Idee, den Wert in Ihren Funktionen \enquote{hard zu coden}. (Andernfalls müssten Sie bei einer Änderung Ihr gesamtes Programm durcharbeiten, und würden sehr wahrscheinlich eine oder mehrere Stellen übersehen).

In diesem Fall ist es also durchaus angebracht, Code zu schreiben wie:
\begin{codebox}[Beispiel: globale Konstante]
\begin{minted}[linenos]{python}
gravitationalConstant = 6.674E-11

def forceBetweenBodies(radius, mass1, mass2) :
  return gravitationalConstant * mass1 * mass2 / (radius**2)
\end{minted}
\end{codebox}
\end{hintbox}

Wenn versucht wird innerhalb einer Funktion ein Symbol des Modullevels umzudefinieren, so legt Python stattdessen eine neue \emph{lokale} Variable an. Das heißt, der Bezug auf die ursprüngliche Variable geht verloren, und in der Funktion ist nur der neue Wert verfügbar. Auf die Modulebene hat dies keinen Einfluss.

Soll tatsächlich von der Funktion aus der Wert der Variablen auf Modulebene geändert werden, so kann dies mit dem Befehl \inPy{global} geschehen. Mit \inPy{global Symbol} wird dem Python-Interpreter mitgeteilt, dass mit \inPy{Symbol} tatsächlich immer das Objekt der Modulebene gemeint ist.

\begin{codebox}[Beispiel: lokale und globale Variablen]
\begin{minted}[linenos]{python}
foo = "foo"
bar = "bar"

def Vercingetorix() :
    foo = "fu"        # lokale Variable
  
    global bar        # Variable 'bar' aus dem Modulelevel
    bar = "baz"

    print("Vercingetorix: foo =", foo)
    print("Vercingetorix: bar =", bar)

Vercingetorix()

print("on module level: foo =", foo)
print("on module level: bar =", bar)
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Übergabe von Immutables]
\begin{minted}{text}
Vercingetorix: foo = fu
Vercingetorix: bar = baz
on module level: foo = foo
on module level: bar = baz
\end{minted}
\end{cmdbox}

Mit \emph{Modulebene} ist dabei immer die \emph{unterste Ebene} in Ihrem Code gemeint. Wenn Sie den Effekt von \inPy{global} nur auf die nächsthöhere Ebene anwenden wollen (\eg bei verschachtelten Funktionen), so erreichen Sie dies durch das Schlüsselwort \inPy{nonlocal}. Die Syntax und Verwendung ist dabei exakt dieselbe. Jedoch kann \inPy{nonlocal} nicht dazu verwendet werden, um auf Objekte der Modulebene zuzugreifen.

\section{Default-Parameter, Positional Arguments und Keyword Arguments}
Oft schreiben wir Funktionen, die fast jedes Mal mit denselben Parametern aufgerufen werden. Es kann lästig werden, diese immer wieder und wieder einzugeben. Denken Sie dazu an das Beispiel Funktion \enquote{ohne} Rückgabewert zurück: die Funktion \inPy{printBoxed} braucht einen Wert \texttt{boxSize} für die Breite der Box. Meistens werden wir aber immer dieselbe Breite erzeugen wollen, um dem User unseres Programms ein einheitliches Interface zu bieten. Das bedeutet leider zunächst, dass wir bei jedem Aufruf unserer Funktion \inPy{printBoxed} diesen Standard-Wert immer wieder mit übergeben müssen.

In Python ist es jedoch möglich, solche Standardwerte zu definieren. Beim Aufruf dürfen diese dann einfach weggelassen werden, können jedoch auch explizit durch einen anderen Wert ersetzt werden. Sie erreichen dies, indem sie in der ersten Zeile der Funktion (in der Funktionssignatur) hinter einen Parameter ein \inPy{= defaultWert}  setzen.

\begin{codebox}[Syntax: Funktionen mit default-Parameter]
\begin{minted}{python}
def Funktionsname (Parameter1, ..., ParameterDefault = Defaultwert) :
    normaler Code
\end{minted}
\end{codebox}

Im Beispiel unserer Box kann das so aussehen:

\begin{codebox}[Beispiel: Funktion mit default-Parameter]
\begin{minted}[linenos]{python}
import math

def printBoxed(text, boxSize = 60) :
    # Draws text in a box like:
    #
    # +-----------+
    # |   text    |
    # +-----------+
  
    lenText     = len(text)
    countSpaces = boxSize - lenText - 2        # 2 spaces for |borders|
    spacesLeft  = math.floor(countSpaces / 2)  # round down
    spacesRight = math.ceil (countSpaces / 2)  # round up
  
    print("+" +               (boxSize - 2) * "-"           + "+")
    print("|" + spacesLeft * " " + text + spacesRight * " " + "|")
    print("+" +               (boxSize - 2) * "-"           + "+")
  
printBoxed("Don't forget to be awesome!")
printBoxed("This is a small box", 25)
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Übergabe von Immutables]
\begin{minted}{text}
+----------------------------------------------------------+
|               Don't forget to be awesome!                |
+----------------------------------------------------------+
+-----------------------+
|  This is a small box  |
+-----------------------+
\end{minted}
\end{cmdbox}

Wird also nur ein Parameter angegeben, so wird für den zweiten automatisch der default-Wert \inPy{60} eingesetzt.

Funktionen dürfen beliebig viele default-Parameter haben. Diese Parameter mit Vorgabewert müssen aber \emph{hinter} den normalen Parametern stehen. Im Aufruf dürfen Parameter auch nur \enquote{von hinten weg} weggelassen werden:
\begin{codebox}[Beispiel: Funktion mit mehreren default-Parametern (1)]
\begin{minted}[linenos]{python}
def defaults(a, b, c=0, d=0) :
  print(a, b, c, d)
  
defaults(1, 2)              # ok, Ausgabe: 1 2 0 0 
defaults(1, 2, 3, 4)        # ok, Ausgabe: 1 2 3 4
defaults(1, 2, 3)           # ok, Ausgabe: 1 2 3 0
# defaults(1, 2,  , 4)      ! Fehler: Unzulässige Syntax
\end{minted}
\end{codebox}

Um das Verhalten zu erreichen, das in der letzten (fehlerhaften) Zeile des obigen Beispiels angedeutet wird, kann \emph{im Funktionsaufruf} durch ein Gleichheitszeichen erklärt werden, welcher Parameter denn gemeint ist. Die Reihenfolge muss dann nicht eingehalten werden! Allerdings müssen diejenigen Parameter, die rein über ihre Position in der Liste identifiziert werden sollen, zuerst genannt werden. Man nennt solche Parameter, die über ein Schlüsselwort zugewiesen werden \emph{Keyword Arguments}, da sie eben über einen Schlüssel identifiziert werden. Im Gegensatz dazu nennt man Parameter, die nur über ihre Position in der Liste zuordbar sind \emph{Positional Arguments}.

\begin{codebox}[Beispiel: Funktion mit mehreren default-Parametern (2)]
\begin{minted}[linenos]{python}
def defaults(a, b, c=0, d=0) :
  print(a, b, c, d)
  
defaults(1, 2, d = 4)       # ok, Ausgabe 1 2 0 4
defaults(a=9, b=8)          # ok, Ausgabe 9 8 0 0
defaults(9, c=7, b=8)       # ok, Ausgabe 9 8 7 0
# defaults(1, 2, c=1, c=2)  ! Fehler: Doppelte Zuweisung von c
# defaults(9, a=7, b=0)     ! Fehler: Doppelte Zuweisung von a
# defaults(a=9, 3)          ! Fehler: positional Argument nach keyword argument
\end{minted}
\end{codebox}


\section{Variadische Funktionen}
Sie können Funktionen auch so schreiben, dass eine beliebige Zahl von Werten übergeben werden kann. Dazu müssen Sie nicht etwa eine endlos lange Signatur tippen, sondern können ein neues Syntax-Konstrukt nutzen:

\begin{codebox}[Syntax: Variadische Funktionen (1)]
\begin{minted}{python}
def Funktionsname (positionalArguments, keywordArguments, *variadicArguments) :
    normaler Code
\end{minted}
\end{codebox}

Noch \emph{hinter} den Keyword-Arguments können Sie also durch einen Stern (\inPy{*}) vor dem Parameternamen andeuten, dass hier eine beliebig lange Kette von Werten akzeptiert werden soll. Diese Werte werden automatisch zu einem \inPy{tuple} zusammengepackt, die im Code den Namen trägt, den Sie für \inPy{variadicArguments} angegeben haben.

\begin{codebox}[Beispiel: Durchschnitt vieler Werte mit variadic arguments]
\begin{minted}[linenos]{python}
def average(*args) :
  total = sum(args)
  return total / len(args)

print(average(1, 2, 3, 4, 5))    # Ausgabe: 3.0
\end{minted}
\end{codebox}

Aus naheliegenden Gründen darf es nur ein variadic Argument pro Funktion geben -- andernfalls könnte der Python-Interpreter nicht zuordnen, welcher Wert zu welcher Liste gehören sollte.

Analog zu den variadic Arguments gibt es auch variadic \emph{keyword} Arguments, also eine beliebig lange Folge von Schlüsseln und zugehörigen Werten. Diese werden mit einer ähnlichen Syntax erklärt:

\begin{codebox}[Syntax: Variadische Funktionen (2)]
\begin{minted}{python}
def Funktionsname (positionalArguments, keywordArguments,
                   *variadicArguments, **variadicKeywordArguments) :
    normaler Code
\end{minted}
\end{codebox}

Python packt diese variadischen Keyword-Argumente automatisch zu einem \inPy{dict} zusammen.

\begin{codebox}[Beispiel: variadic keyword arguments]
\begin{minted}[linenos]{python}
def presentMe(**kwargs) :
  print("Here are a few details about me:")
  for (key, value) in kwargs.items() :
      print(key, ": ", value)

presentMe(
    nickname="The Blue Chameleon",
    talents="drinking coffee",
    cellphoneNumber="ask nicely"
)
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: variadic keyword arguments]
\begin{minted}{text}
Here are a few details about me:
nickname :  The Blue Chameleon
talents :  drinking coffee
cellphoneNumber :  ask nicely
\end{minted}
\end{cmdbox}

Wie angedeutet können Sie positional Arguments, keyowrd Arguments, variadic Arguments und variadic keyword Arguments in beliebiger Kombination verwenden. Jedoch muss die Reihenfolge dieser Gruppen sowohl bei der Deklaration als auch beim Aufruf eingehalten werden.

\begin{codebox}[Beispiel: Verschiedene Arten von Parametern im Zusammenspiel]
\begin{minted}[linenos]{python}
def parameterShowcase(a, b, c="default-Param", *args, **kwargs) :
    print("a     :", a)
    print("b     :", b)
    print("c     :", c)
    print("args  :", args)
    print("kwargs:", kwargs)
    print()

parameterShowcase(1, 2)
parameterShowcase(1, 2, "explicit Param", 9, 8, 7)
parameterShowcase(1, 2, "explicit Param", 9, 8, 7, key1="value", key2="VALUE")
parameterShowcase(9, 8, 7, 6, 5, key="value")
parameterShowcase(9, 8, 7, key="value")
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Verschiedene Arten von Parametern im Zusammenspiel]
\begin{minted}{text}
a     : 1
b     : 2
c     : default-Param
args  : ()
kwargs: {}

a     : 1
b     : 2
c     : explicit Param
args  : (9, 8, 7)
kwargs: {}

a     : 1
b     : 2
c     : explicit Param
args  : (9, 8, 7)
kwargs: {'key1': 'value', 'key2': 'VALUE'}

a     : 9
b     : 8
c     : 7
args  : (6, 5)
kwargs: {'key': 'value'}

a     : 9
b     : 8
c     : 7
args  : ()
kwargs: {'key': 'value'}
\end{minted}
\end{cmdbox}

unpacking

some of the params for print

\section{Lambdas}
