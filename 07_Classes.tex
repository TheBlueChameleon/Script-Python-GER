\chapter{Klassen}
\label{chp:Classes}
\epigraph{
	What's the object-oriented way to wealth? -- Inheritance
}{Anonymous}

In ihrem Grundaufbau sind Computer Maschinen, die mit \emph{einzelnen Zahlen} umgehen. \emph{Gruppen} von Zahlen sind alles, was wir brauchen, um unsere Welt zu beschreiben\footnote{Ich bin gerne zu einer philosophischen Diskussion über diese Aussage bereit. Für diesen Kurs wollen wir aber zumindest annähern, dass Zahlen zur Beschreibung von Dingen genügen, die wir mit einem Computer bearbeiten wollen}. Dazu müssen diese Zahlen aber eine gewisse Ordnung und Beziehung zueinander haben und wir brauchen eine geeignete Methode zur Interpretation dieser Zahlen. Die Zahlen 98, 108, 117, 101 können zum Beispiel \emph{in dieser Reiheinfolge} als ASCII-Codes der Buchstaben des Wortes \emph{blue} interpretiert werden; es könnten aber auch die Hausnummern der Adressen meiner ersten vier Lebensgefährtinnen sein\footnote{Sind sie nicht. Ich kann mich nur an die Hausnummer meiner vierten Freundin erinnern (es war die 12), und meine erste Freundin hat so weit von der nächsten Stadt gelebt, dass ich mir nicht sicher bin, ob das Haus überhaupt eine Hausnummer hatte.}.

Für Texte haben wir den Datentyp \inPy{string} kennengelernt. Hinter dem Datentyp steht eine aufwändige Maschinerie, die eben genau diese Ordnung und Interpretation von Zahlengruppen bietet. In diesem Kapitel wollen wir uns damit beschäftigen, eigene solche Konstrukte zu erschaffen: Wir erstellen hier \emph{Klassen}.

Wir wollen uns als Beispiel vorstellen, dass ich in eine Diskussion verwickelt wurde, wer weniger Glück in den vergangenen Beziehungen hatte. Wir werden Python benutzen, um diese Frage mit wissenschaftlicher Methodik zu beantworten. Weiter unten sind die Daten meiner und Charlottes früheren Beziehungen tabellarisch aufgelistet. Diese Tabelle werden wir in Code übersetzen, und damit unsere Streitfrage eindeutig beantworten.

\section{Klassen als Container}
Zunächst sollten Sie sich eine Klasse als Datencontainer vorstellen, wie wir sie schon in Kapitel \ref{chp:Containers} kennengelernt haben\footnote{Tatsächlich sind die dort gezeigten Datentypen Beispiele für Klassen}. Dort wurden mehrere \eg Werte zu einem kompakten \inPy{dict} zusammengefasst. Um einen dieser zusammen gepackten Werte zu greifen, brauchten wir einen \emph{Schlüssel}.

Klassen haben in dieser Hinsicht eine ähnliche Struktur: Sie sind eine Sammlung von Attributen, zu denen man Werte speichern kann. Die Attribute einer Klasse richten sich natürlich danach, was modelliert werden soll. In unserem Beispiel sind das die Eigenschaften der früheren PartnerInnen. Attribute können dann so etwas sein wie \emph{Name}, \emph{Körpergröße}, \emph{positive Eigenschaften} oder \emph{negative Eigenschaften}.

Wir können uns in dem Kontext eine Tabelle vorstellen, in der wir unsere Verflossenen auflisten könnte. Die Spaltenüberschriften dieser Tabelle wären dann die Attribute. Jede Zeile dieser Tabelle nennen wir eine \emph{Instanz} der Klasse. Eine Instanz beschreibt in diesem Fall also einen konkreten Menschen, der (unter anderem) durch die Attribute \emph{name}, \emph{height}, \emph{upsides} und \emph{downsides} beschrieben werden kann. Eine Instanz braucht außerdem noch ein \emph{Symbol}, über den klar wird, welche Zeile der Tabelle gemeint ist (schließlich ist es zumindest denkbar, dass zwei gleich große Menschen mit demselben Namen existieren, an denen wir dieselben Vorzüge und Nachteile sehen).

\begin{tcolorbox}[title=Eine Liste von Liebschaften]
\begin{center}
\textbf{Stefans romantische Vergangenheit}
\rowcolors{1}{tabhighlight}{tabcontrast}
\begin{tabular}{c|ccp{.3\linewidth}p{.3\linewidth}}
	\textbf{Symbol} & \textbf{Name} & \textbf{Height} & \textbf{Upsides}                                 & \textbf{Downsides} \tabcrlf
	\texttt{exgf1}  & Steffie       & 1.65 m          & intelligent, beautiful, has a dog                & too attached to her mother, 
																																																				doesn't like meeting people \\
	\texttt{exgf2}  & Arista        & 1.60 m          & very intelligent, beautiful, good taste in music & doesn't like coffee, doesn't like coding \\
	\texttt{exgf3}  & Katja         & 1.81 m          & intelligent, very beautiful, musician            & moody, cheated on me
\end{tabular}
\end{center}

\begin{center}
\textbf{Charlottes gebrochene Herzen}
\rowcolors{1}{tabhighlight}{tabcontrast}
\begin{tabular}{c|ccp{.3\linewidth}p{.3\linewidth}}
	\textbf{Symbol} & \textbf{Name} & \textbf{Height} & \textbf{Upsides}                                 & \textbf{Downsides} \tabcrlf
	\texttt{exbf1}  & Sebastian     & 1.78 m          & intelligent, handsome, likes to listen           & obsessed with catching bugs, always late \\
	\texttt{exbf2}  & Reginald      & 1.84 m          & very intelligent, handsome, plays in a band      & flirty with everyone, complains a lot \\
	\texttt{exbf3}  & Sönke         & 1.81 m          & intelligent, quite handsome, cheerful nature     & superficial, racist
\end{tabular}
\end{center}
Ich sollte anmerken, dass diese Tabelle keine echten Menschen beschreibt. Weder die Namen noch die Eigenschaften stimmen mit tatsächlichen ExpartnerInnen überein. Die genannten Eigenschaften sollen anschauliche Beispiele geben, sind aber zwingend nicht als Wertung von Eigenschaften im echten Leben zu verstehen\footnote{Still, racism sucks.}.
\end{tcolorbox}

Dies wollen wir nun in Code abbilden. Wir beschreiben also die \emph{Klasse Expartner}. Dazu brauchen wir ein neues Syntaxelement:
\begin{codebox}[Syntax: Klassen]
\begin{minted}{python3}
class Klassenname  :
    Attribut1 = Standardwert
    Attribut2 = Standardwert
    ...
\end{minted}
\end{codebox}

Wie also schon bei Funktionen gibt die Einrückungsebene an, was zur Klasse gehört, und was dem restlichen Code zugeordnet wird. Der \emph{Standardwert} wird beim Erstellen der Instanzen zugewiesen, steht also \enquote{in unserer Tabelle}, wenn eine neue Zeile erstellt wird.

Wir legen eine Instanz mit der folgenden Syntax an:
\begin{codebox}[Syntax: Instanzen anlegen]
\begin{minted}{python3}
Instanz = Klassenname()
\end{minted}
\end{codebox}

Beachten Sie die leeren Klammern! Diese sind nötig, um Python mitzuteilen, dass wirklich eine \emph{Instanz} angelegt werden soll. Ohne die Klammern erstellen Sie eine Kopie der Klasse, also eine neue Tabelle.

Sie können nun sowohl lesend als auch schreibend auf die Tabelle zugreifen, indem Sie Klasse und Attribut mit einem Punkt verbinden:
\begin{codebox}[Syntax: Zugriff auf Klassenelemente]
\begin{minted}{python3}
Instanz.Attribut = Wert   # Schreibender Zugriff
print(Instanz.Attribut)   # Beispiel für lesenenden Zugriff
\end{minted}
\end{codebox}

Damit können wir die obige Tabelle so in Code übersetzen:
\begin{codebox}[Beispiel: Klassen als reine Container]
\begin{minted}[linenos]{python3}
class Expartner :
    name      = None
    height    = None
    upsides   = {}
    downsides = {}

exgf1.name      = "Steffie"
exgf1.height    = 1.65
exgf1.upsides   = {"intelligent", "beautiful", "has a dog"}
exgf1.downsides = {"too attached to her mother", "doesn't like meeting people"}

...

print(exgf1.name)    # Ausgabe: Steffie
\end{minted}
\end{codebox}

Wir wählen hier \{\inPy{set}s\} für die Attribute \inPy{upsides} und \inPy{downsides}, da eine Eigenschaft für jede Exfreundin nur einmal vergeben werden darf. Es soll also keine Instanz von \inPy{Expartner} geben, die \inPy{{"funny", "funny"}} ist.

\begin{hintbox}[Klassennamen mit Großbuchstaben]
Es ist Konvention, Klasennamen mit einem Großbuchstaben beginnen zu lassen, während die Instanzen -- wie alle Variablen -- mit einem Kleinbuchstaben beginnen sollten. Die Attribute verhalten sich auf eine gewisse Weise wie Variablen und werden daher auch mit Kleinbuchstaben beschrieben.
\end{hintbox}

Wir haben oben die Instanzen der Klasse \inPy{Expartner} als Tabelle dargestellt. Dies soll nicht den Eindruck vermitteln, als würden diese nur als Einheit existieren. Jede Instanz existiert komplett unabhängig von den anderen. Sie können sich vorstellen, dass die oben gezeigte Tabelle mit einer Schere in einzelne Zeilen geschnitten wurde. Durch das gemeinsame Format (\ie das Vorhandensein gleicher Attribute) gibt es aber einen thematischen Zusammenhang.

Das bedeutet, dass auch die Gedanken zu lokalen und globalen Variablen auf Klassen anwendbar sind. Instanzen einer Klasse können in Funktionen angelegt werden, und existieren dann nur dort. Sie können auch als Parameter an Funktionen übergeben werden, und von diesen verändert werden. Änderungen an den Attributen sind auch an der aufrufenden Stelle zu sehen solange der Speicherort der Instanz selbst sich nicht ändert:

\begin{codebox}[Beispiel: Instanzen als Funktionsparameter]
\begin{minted}[linenos]{python3}
# Klasse Expartner und Instanz exgf1 wie oben

def makeNameUppercase(ex) :
    ex.name = ex.name.upper()

def showEx(ex) :
    print(ex.name)
    print("  Height      : " + str(ex.height))
    print("  Upsides     : " + str(ex.upsides)  [1:-1])
    print("  Downsides   : " + str(ex.downsides)[1:-1])

makeNameUppercase(exgf1)
showEx(exgf1)
\end{minted}
\end{codebox}
(Das Slicing (\inPy{[1:-1]}) soll hierbei nur die \inPy{set}-Klammern \{\} verbergen.)
\begin{cmdbox}[Ausgabe: Instanzen als Funktionsparameter]
\begin{minted}{text}
STEFFIE
  Height      : 1.65
  Upsides     : 'beautiful', 'has a dog', 'intelligent'
  Downsides   : "doesn't like meeting people", 'too attached to her mother'
\end{minted}
\end{cmdbox}

Um zu verstehen, warum diese Änderung durch \inPy{makeNameUppercase} auch weitergegeben wird, sollten wir uns nochmal ein Bild des Arbeitsspeichers zeichnen:

\parbox{\linewidth}{
\begin{tcolorbox}[title=Speicherbild]
\begin{center}
\begin{tikzpicture}
  [ 
    cell/.style={text width=13mm,
      text height=4mm, draw=black, inner sep=1mm},
    ld/.style={draw=blue,shorten >=2pt,->}
  ]
  
  \node (a1) at ( 0.0,4) [cell] {\ttfamily ...};
  \node (a2) at ( 1.5,4) [cell] {\ttfamily Ref};
  \node (a3) at ( 3.0,4) [cell] {\ttfamily Ref};
  \node (a4) at ( 4.5,4) [cell] {\ttfamily Ref};
  \node (a5) at ( 6.0,4) [cell] {\ttfamily Ref};
  \node (a6) at ( 7.5,4) [cell] {\ttfamily ...};
  \node (a7) at ( 9.0,4) [cell] {\ttfamily Steffie};
  \node (a8) at (10.5,4) [cell] {\ttfamily ...};
  \node (a9) at (12.0,4) [cell] {\ttfamily ...};
  \node (a0) at (13.5,4) [cell] {\ttfamily ...};

  \node (A2) [below=2mm of a2, color=teal] {\tiny 0x2800};
  \node (A3) [below=2mm of a3]             {\tiny 0x2801};
  \node (A4) [below=2mm of a4]             {\tiny 0x2802};
  \node (A5) [below=2mm of a5]             {\tiny 0x2803};
  \node (A7) [below=2mm of a7]             {\tiny 0x64F4};
  \node (A9) [below=2mm of a9]             {\tiny 0xB100};
  
  \node (gfpre) [below=0mm of A2, color=teal] {\scriptsize Adresse von \texttt{exgf1}};
  
  \draw [->] (a2.north) arc [x radius = 3.75, y radius = 0.5, start angle = 180, end angle = 10];
  
  \draw [double,->] (7, 3) to (7, 2);
  \node (call) at (9, 2.5) {\texttt{makeNameUppercase}};
	
  \node (b1) at ( 0.0,1) [cell] {\ttfamily ...};
  \node (b2) at ( 1.5,1) [cell] {\ttfamily Ref};
  \node (b3) at ( 3.0,1) [cell] {\ttfamily Ref};
  \node (b4) at ( 4.5,1) [cell] {\ttfamily Ref};
  \node (b5) at ( 6.0,1) [cell] {\ttfamily Ref};
  \node (b6) at ( 7.5,1) [cell] {\ttfamily ...};
  \node (b7) at ( 9.0,1) [cell] {\ttfamily Steffie};
  \node (b8) at (10.5,1) [cell] {\ttfamily ...};
  \node (b9) at (12.0,1) [cell] {\ttfamily STEFFIE};
  \node (b0) at (13.5,1) [cell] {\ttfamily ...};

  \node (B2) [below=2mm of b2, color=teal] {\tiny 0x2800};
  \node (B3) [below=2mm of b3]             {\tiny 0x2801};
  \node (B4) [below=2mm of b4]             {\tiny 0x2802};
  \node (B5) [below=2mm of b5]             {\tiny 0x2803};
  \node (B7) [below=2mm of b7]             {\tiny 0x64F4};
  \node (B9) [below=2mm of b9]             {\tiny 0xB100};
  
  \node (gfpost) [below=0mm of B2, color=teal] {\scriptsize Adresse von \texttt{exgf1}};
  
  \draw [->] (b2.north) arc [x radius = 5.25, y radius = 0.5, start angle = 180, end angle = 10];
\end{tikzpicture}
\end{center}
\end{tcolorbox}
\captionof{figure}{Speicherbild: Klasse als Sammlung von Referenzen}}

Das Symbol \inPy{exgf1} ist eine Referenz auf eine Speicherstelle, die selbst wiederum vier Referenzen enthält: Auf \inPy{name}, \inPy{height}, \inPy{upsides} und \inPy{downsides}. Wenn wir nun eine Änderung des Namens programmieren, so wird die Referenz \inPy{name} eben auf eine neue Speicherstelle geschickt. Der Ort, an dem diese Referenz zu finden ist, ändert sich aber nicht; \inPy{exgf1} muss nicht \enquote{umziehen}\footnote{Genau wie alle Exfreundinnen, mit denen ich bisher zusammen gewohnt habe.}.

Im folgenden Beispiel dagegen wird in der Funktion eine neue Speicherstelle angelegt; damit sind die Änderungen nach Funktionsaufruf auch nicht mehr sichtbar:
\begin{codebox}[Beispiel: Lokale Instanz]
\begin{minted}[linenos]{python3}
# Klasse Expartner, Instanz exgf1 und showEx wie oben

def makePerfect(ex) :
    ex = Expartner()
    ex.name = "The perfect one"
    ex.height = 1.70
    ex.upsides = {"very intelligent", "very beautiful", "good taste in music",
                  "has a dog", "musician", "likes coffee"}
    print("in makePefect:")
    showEx(ex)
    
makePerfect(exgf1)
print("in module level:")
showEx(exgf1)
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Lokale Instanz]
\begin{minted}{text}
in makePefect:
The perfect one
  Height      : 1.7
  Upsides     : 'good taste in music', 'has a dog', 'musician', 'likes coffee',
                'very intelligent', 'very beautiful'
  Downsides   : 
in module level:
STEFFIE
  Height      : 1.65
  Upsides     : 'has a dog', 'beautiful', 'intelligent'
  Downsides   : 'too attached to her mother', "doesn't like meeting people"
\end{minted}
\end{cmdbox}

Der bedeutende Unterschied liegt also in Zeile 4: Hier wird dem lokalen Symbol \inPy{ex} eine Referenz auf eine neue Speicherstelle gegeben (\inPy{Expartner()} erzeugt quasi eine neue Speicherstelle). In der Funktion \inPy{makePerfect} kann dann wie üblich auf diese \emph{neue} Speicherstelle zugegriffen werden; dies ändert aber nichts daran, dass \inPy{exgf1} in der Modulebene immer noch auf den ursprünglichen Datensatz zeigt; an \enquote{STEFFIE} ändert sich nichts\footnote{Vielleicht auch besser so -- sonst müsste ich mich fragen, warum wir nicht mehr zusammen sind.}.

Auch ohne, dass dies in der Definition der Klasse angegeben wurde, können einzelnen Instanzen neue Attribute hinzugefügt werden. Dies betrifft dann aber nur \emph{eine spezielle Instanz}, ohne an der Definition der Klasse etwas zu ändern:
\begin{codebox}[Beispiel: Dynamische Erweiterung]
\begin{minted}[linenos]{python3}
# Klasse Expartner wie oben

exbf1 = Expartner()
exbf2 = Expartner()

exbf2.eyeColor = "blue"  # neues Attribut nur für exbf2 angelegt

print(exbf2.eyeColor)    # Ausgabe: blue
#print(exbf1.eyeColor)   ! Fehler: Attribut "eyeColor" existiert in exbf1 nicht.
\end{minted}
\end{codebox}

Ebenso kann auch die \emph{Klasse als Ganzes} dynamisch verändert werden. Das bedeutet, wir können neue Attribute erstellen, die jede Instanz der Klasse \enquote{nachträglich} hinzugefügt wird. Dies geschieht einfach über
\begin{codebox}[Syntax: Klassen dynamisch erweitern]
\begin{minted}{python3}
Klasse.Attribut = Wert
\end{minted}
\end{codebox}

Hier wird also wirklich die \emph{Klasse} genannt, nicht nur eine einzige Instanz. Entsprechend wirkt sich diese Änderung auch auf alle Instanzen (\eg \inPy{exbf1, exgf2, ...} aus).

\section{Methods}
Bis hierhin haben wir Klassen nur als etwas aufwändigere Variante eines \inPy{dict}s benutzt: Wir haben Schlüssel-Wertpaare (\eg \inPy{name: "Sönke"}) gebildet, und diese mit einem gemeinsamen Symbol ansprechbar gemacht. Jetzt aber erweitern wir Klassen um \emph{Methoden}, \ie Funktionen, die einen speziellen Bezug auf die Instanzen der Klasse haben.

Wir erreichen dies, indem wir die Funktion \emph{in der Klasse} definieren, und als ersten Parameter \inPy{self} verlangen:
\begin{codebox}[Syntax: Klassen mit Methoden]
\begin{minted}{python3}
class Klassenname  :
    def Methode(self, weitereParameter ...) :
       normaler Code
\end{minted}
\end{codebox}

Dieser verpflichtende Parameter \inPy{self} wird automatisch beim Aufruf übergeben, und enthält eine Referenz auf die Instanz, auf die die Methode angewandt werden soll. Aufgerufen werden Methoden ähnlich dem Zugriff auf die Attribute:
\begin{codebox}[Syntax: Aufruf von Methoden]
\begin{minted}{python3}
Instanz.Methode(weitereParameter)
\end{minted}
\end{codebox}

Dabei müssen wirklich nur \inPy{weitereParameter} übergeben werden; der Wert für \inPy{self} wird durch die Angabe der Instanz ganz zu Beginn dieses Konstrukts schon ermittelt.

Das folgende Beispiel illustriert Klassen mit Methoden sowie ihre Verwendung:
\begin{codebox}[Beispiel: Klasse mit Methoden]
\begin{minted}[linenos]{python3}
class Expartner :
    name      = None
    height    = None
    upsides   = {}
    downsides = {}
    
    def areThey(self, trait) :
        return (trait in self.upsides) or (trait in self.downsides)

exbf1.name      = "Sebastian"
exbf1.height    = 1.78
exbf1.upsides   = {"intelligent", "handsome", "likes to listen"}
exbf1.downsides = {"obsessed with catching bugs", "always late"}

print("Sebastian is intelligent:", exbf1.areThey("intelligent")) # Ausgabe: True
\end{minted}
\end{codebox}

Natürlich hätten wir zu diesem Zweck auch eine Funktion \inPy{isExpartner(ex, trait)} schreiben können. Der Vorteil von Methoden liegt darin, dass sie fest einer Klasse zugewiesen sind, und somit nur in einem \enquote{sinnvollen Kontext} verwendet werden können. Der normalen Funktion \inPy{isExpartner(ex, trait)} können wir als ersten Parameter auch eine Instanz der Klasse \inPy{Partner} übergeben. Natürlich hat die Klasse \inPy{Partner} kein Attribut \inPy{downsides}; daher wird unser Programm abstürzen, wenn wir dies versuchen. Bei Methoden hingegen kommen wir gar nicht erst in die Gelegenheit, diesen Fehler zu machen. (Leider gilt diese Typensicherheit nicht für die weiteren Parameter. Methoden nehmen also eine Fehlerquelle ab, nicht aber alle).

Daneben gewinnen wir Freiraum bei der Namensgebung: Die Klasse \inPy{Partner} kann ihre eigene Methode \inPy{areThey(self, trait)} haben. Diese Methode kann auf eine beliebige Art implementiert werden und so der Tatsache Rechnung tragen, dass die Klasse \inPy{Partner} eben kein Attribut \inPy{downsides} hat. Obwohl die Implementierung sich unterscheidet, sind beide Methoden in der Anwendung (\enquote{im Interface}) gleich. Wir können sowohl \inPy{oneOfMyExGirlfriends.areThey("beautiful")} als auch \inPy{myGirlfriend.areThey("beautiful")} setzen, und erhalten ein sinnvolles Ergebnis. Dies ist wichtig, sobald Ihre Codes länger als ein paar Zeilen werden. Sie müssen dann nicht mehr so viele Details über Ihr Programm im Kopf behalten (hieß die Funktion jetzt \inPy{isExPartner} oder \inPy{isExpartner}?), sondern können darauf vertrauen, dass ähnliche Klassen auch ein ähnliches \emph{Interface} bieten (\ie dass die Methoden gleich heißen und gleiche Parameter verlangt werden).

Methoden dürfen auch ohne Parameter definiert werden, müssen aber immer noch das obligatorische \inPy{self} entgegen nehmen. Damit können wir folgenden Code schreiben, und damit die vergangenen Beziehungen miteinander vergleichen:
\begin{codebox}[Beispiel: Klasse mit Methode ohne Parameter]
\begin{minted}[linenos]{python3}
class Expartner :
    traits = {
        "good taste in music"         :   2,
        "beautiful"                   :   3,
        "handsome"                    :   3,
        "intelligent"                 :   5,
        "very beautiful"              :   5,
        "very handsome"               :   5,
        "very intelligent"            :  10,
        "doesn't like coding"         : - 4,
        "doesn't like meeting people" : - 4,
        "complains a lot"             : - 8,
        "cheated on me"               : -20,
        "racist"                      : -30
    }
    name      = None
    height    = None
    upsides   = {}
    downsides = {}
    
    def rating(self) :
        reVal = 0
        for trait in self.upsides :
            if trait in self.traits : reVal += self.traits[trait]
            else                    : reVal += +1
        for trait in self.downsides :
            if trait in self.traits : reVal += self.traits[trait]
            else                    : reVal += -1
        return reVal

exbf2 = Expartner()

exbf2.name      = "Reginald"
exbf2.height    = 1.84
exbf2.upsides   = {"very intelligent", "handsome", "plays in a band"}
exbf2.downsides = {"flirty with everyone", "complains a lot"}

print("Rating of time with ", exbf2.name, ": ", exbf2.rating(), sep = "")
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Klasse mit Methode ohne Parameter]
\begin{minted}{text}
Rating of time with Reginald: 5
\end{minted}
\end{cmdbox}

Das Attribut \inPy{traits} ist Teil der Klasse \inPy{Expartner}. Damit hat also auch jede Instanz ein eigenes Feld, in dem Bewertungskriterien eingetragen werden können. Wir haben also die Möglichkeit, \enquote{nochmal nachzujustieren}. Vielleicht war Arista zwar \enquote{nur} \inPy{"beautiful"}, aber doch um ein bisschen hübscher als Steffie. Wir könnten also folgenden -- fehlerhaften! -- Code schreiben (in den wir aus didaktischen Gründen auch Zeile 23 einfügen und im Anschluss erklären):
\begin{warnbox}[Beispiel: Versehentliches Ändern von Referenzen, leftupper=7mm]
\begin{minted}[linenos]{python3}
# Klasse Expartner wie oben

exgfs = [Expartner(), Expartner(), Expartner()]

exgfs[0].name      = "Steffie"
exgfs[0].height    = 1.65
exgfs[0].upsides   = {"intelligent", "beautiful", "has a dog"}
exgfs[0].downsides = {"too attached to her mother",
                      "doesn't like meeting people"}
exgfs[1].name      = "Arista"
exgfs[1].height    = 1.60
exgfs[1].upsides   = {"very intelligent", "beautiful", "good taste in music"}
exgfs[1].downsides = {"doesn't like coding", "doesn't like coffee"}
exgfs[2].name      = "Katja"
exgfs[2].height    = 1.81
exgfs[2].upsides   = {"intelligent", "very beautiful", "musician"}
exgfs[2].downsides = {"moody", "cheated on me"}

print("Evaluation 1:")
for ex in exgfs :
  print(ex.name, ": ", ex.rating(), sep="")

gfs[1].traits["beautiful"] = 3.5
gfs[2].traits = dict()

print("\nEvaluation 2:")
for ex in exgfs :
  print(ex.name, ": ", ex.rating(), sep="")
\end{minted}
\end{warnbox}

\begin{cmdbox}[Ausgabe: Versehentliches Ändern von Referenzen]
\begin{minted}{text}
Evaluation 1:
Steffie: 4
Arista: 10
Katja: -10

Evaluation 2:
Steffie: 4.5
Arista: 10.5
Katja: 1
\end{minted}
\end{cmdbox}

Obwohl wir scheinbar nur die \inPy{traits} von \inPy{exgfs[1]} (also Arista) ändern, sehen wir in der Evaluation 2, dass sich auch die Bewertung von Steffie geändert hat! Dagegen hatte Zeile 23 -- das völlige Löschen der Bewertungskriterien -- nur Einfluss auf Katja.

Grund ist wie schon öfter, dass Python mit Referenzen arbeitet. Jede Instanz von \inPy{Expartner} hat zwar seine eigene \emph{Referenz} \inPy{traits}; diese können jedoch auf dieselbe Speicherstelle zeigen. In Zeile 22 wird damit das \emph{gemeinsame} \inPy{dict} der Bewertungskriterien von allen drei \inPy{Expartner}s geändert. Zeile 24 dagegen legt ein komplett neues (leeres) \inPy{dict} an und gibt eine Referenz auf dieses neue \inPy{dict} an Katja.

Wir könnten \inPy{copy} benutzen, um dieses Problem zu umgehen.

\section{Magic Methods (Dunders)}
Einige Namen für Methoden werden automatisch an bestimmten Stellen aufgerufen. Diese automatischen Aufrufe erlauben es, dem Code eine sehr viel kompaktere, klarere Form zu geben. Allen Methoden ist gemein, dass sie mit einem Doppelten Unterstrich (\texttt{\_\_}) beginnen und auch mit diesen beiden Zeichen enden. Wegen diesem \emph{double underscore} werden die hier gezeigten Methoden auch \emph{Dunders} genannt. Daneben ist auch der Name \emph{Magic Methods} gebräuchlich. Alle diese Dunders \emph{können} auch wie ganz normale Methoden aufgerufen werden; vorgesehen sind sie aber zu anderen Zwecken:

\subsection{Initializer: \inPy{__init__}}
Mit \inPy{__init__} wird ein \emph{Initializer} beschrieben, also eine Funktion, die aufgerufen wird, sobald eine neue Instanz einer Klasse angelegt wird. Üblicherweise werden hier die Werte der einzelnen Attribute gesetzt. Gegebenenfalls können auch Gültigkeitsprüfungen eingeführt werden. Beispielsweise können wir damit unsere Klasse folgendermaßen erweitern:

\begin{codebox}[Beispiel: Klasse mit Initializer]
\begin{minted}[linenos]{python3}
class Expartner :
    traits = {
        "intelligent"                 :   5,
        # ... andere traits ...
    }
    
    name = None
    # ... andere Attribute ...
    
    def __init__(self, name = None, height = None,
                 upsides = {}, downsides = {}) :
        if height < 0 :
            raise Exception("Your Ex cannot be less than 0.0m tall")
        
        self.name      = name
        self.height    = height
        self.upsides   = upsides
        self.downsides = downsides
    
ex = Expartner("Arista" , 1.60, 
               {"very intelligent", "beautiful", "good taste in music"},
               {"doesn't like coding", "doesn't like coffee"})
\end{minted}
\end{codebox}

Der Befehl \inPy{raise} ist ihnen noch neu, und wird im Detail in Kapitel \ref{chp:Exceptions} besprochen. An dieser Stelle reicht es zu wissen, dass damit die Programmausführung mit Fehlermeldung (\emph{Your Ex cannot be less than 0.0m tall}) abgebrochen wird.

Entsprechend finden Sie nun folgendes Verhalten:
\begin{codebox}[Beispiel: Ungültiger Parameter im Initializer]
\begin{minted}[linenos, firstnumber=24]{python3}
gotye = Expartner("Somebody That I Used To Know", -1)
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Ungültiger Parameter im Initializer]
\begin{minted}{text}
Traceback (most recent call last):
  File "expartners.py", line 24, in <module>
    Expartner("Somebody That I Used To Know", -1)
  File "expartners.py", line 13, in __init__
    raise Exception("Your Ex cannot be less than 0.0m tall")
Exception: Your Ex cannot be less than 0.0m tall
\end{minted}
\end{cmdbox}

Die Zeilen 20-22 sind der Aufruf des Dunders \inPy{__init__}. Sie sehen, wie viel Komfort Sie hiermit gewinnen: Ab jetzt können Sie einfach die Beschreibung der Instanz  in einer kompakten Form erledigen, und müssen nicht mehr Attribut für Attribut explizit benennen, bevor Sie die Werte eintragen. Vor allem aber gewinnen Sie so den Luxus einer automatischen Prüfung auf Sinnhaftigkeit. Im obigen Beispiel wird es unmöglich gemacht, eine Instanz von \inPy{Expartner} anzulegen, in der das Attribut \inPy{height} negativ ist\footnote{Natürlich bleibt es möglich, explizit \inPy{ex.height = -1} zu programmieren. Zumindest beim Erstellen der Instanz sind Sie so aber auf der sicheren Seite. Gängige Praxis ist es, für jedes Attribut eine Methode \inPy{getAttribute(self)} und \inPy{setAttribute(self, newValue)} zu schreiben. Wie die Namen es vermuten lassen, sollen diese den Lese- und Schreibzugriff auf die Attribute handeln, und können so zum Beispiel auch Gültigkeitsprüfungen einführen. In Kapitel \ref{chp:Classes2} werden wir hierfür eine besonders bequeme Möglichkeit kennen lernen}.

Auch im Initializer dürfen Attribute definiert werden. Sie erinnern sich, dass wir schon zuvor \\\inPy{ex.eyeColor = "blue"} programmieren konnten. Damit wurde die Instanz \inPy{ex} zu einer Abwandlung der Klasse \inPy{Expartner} mit dem \emph{zusätzlichen Attribut} \inPy{eyeColor}. Wenn wir nun also im Initializer ein neues Attribut definieren, dann hat also jede \emph{Instanz} auch das entsprechende Attribut; \emph{die Klasse selbst} hat dieses Attribut aber nicht.

Wir können hierzu den Befehl \inPy{dir} benutzen: Dieser Befehl listet alle Attribute und Methoden eines Objekts auf. Ein Objekt kann dabei sowohl ein Datentyp (\ie eine Klasse), eine Variable oder auch ein komplexer Ausdruck sein.

\begin{codebox}[Beispiel: \texttt{dir}]
\begin{minted}[linenos]{python3}
class Empty :
    def __init__(self) :
        self.attribute = "something"

myBrain = Empty()

print("Instanz:\n", dir(myBrain), "\n")
print("Klasse :\n", dir( Empty ), "\n")
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: \texttt{dir}]
\begin{minted}{text}
Instanz:
 ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', 
  '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', 
  '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', 
  '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', 
  '__str__', '__subclasshook__', '__weakref__', 'attribute'] 
\end{minted}
\end{cmdbox}
%
\begin{cmdbox}[]
\begin{minted}{text}
Klasse :
 ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', 
  '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', 
  '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', 
  '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', 
  '__str__', '__subclasshook__', '__weakref__']
\end{minted}
\end{cmdbox}
Auf den ersten Blick sehen Sie, dass bereits eine Menge Dunders automatisch angelegt werden, die wir hier leider nur zum Teil besprechen können. Bei genauerer Betrachtung finden Sie, dass die Ausgabe für die Instanz zwar \inPy{attribute} aufführt; in der Ausgabe für die Klasse hingegen fehlt dieses Element.

\begin{hintbox}[\texttt{dir} als Gedächtnisstütze]
Sie werden sich oft in der Situation finden, dass Sie zwar wissen \emph{dass} es einen Dunder gibt, der eine bestimmte Aufgabe erledigt, dass sie aber nicht mehr \emph{genau} wissen, wie dieser heißt. Natürlich können Sie in diesem Lehrbuch nachlesen oder schnell im Internet suchen. Häufig ist es aber die schnellste Option, die Ausgabe von \inPy{dir} für eine bestehende Klasse (wie \inPy{int} oder \inPy{list}) zu durchsuchen.

Wenn Sie das tun werden Sie zwangsläufig auch über Methoden stoßen, die Ihnen noch nicht bekannt sind. Viele Methoden haben einen Namen, der auch ohne tiefere Kenntnisse in Programmiertechniken für Sie jetzt gut deutbar ist: Beispielsweise hat die Klasse \inPy{float} eine Methode \inPy{as_integer_ratio()}. Für andere Methoden werden Sie nach kurzer Webrecherche eine gute (\idR englische) Erklärung finden.

Ich will Sie hiermit dazu ermutigen, die Sprache Python auch selbstständig zu erkunden. Kein Lehrbuch kann den massiven Sprachumfang vollständig erklären; daher gehört es auch zu Ihrer Aufgabe als ProgrammiererIn, sich selbst in Techniken und Konzepte einzuarbeiten.
\end{hintbox}

\begin{hintbox}[Attribute in \texttt{\_\_init\_\_} anlegen]
Wir haben gesehen, dass Attribute der Klasse zunächst von allen Instanzen geteilt werden. Wie Sie gesehen haben, kann dies Probleme bereiten. Wir umgehen dies, indem wir die Attribute zu jeder \emph{Instanz} separat hinzufügen. Das geht am einfachsten, indem wir die Attrubte im Dunder \inPy{__init__} definieren. Im folgenden Text behalte ich die Attribute der Klasse \inPy{Expartner} in der Definition der Klasse selbst, um interne Mechanismen zu verdeutlichen. Ihnen will ich aber nahelegen, Zeilen der Form \inPy{Attribut = Standardwert} in der Methode \inPy{__init__} zu schreiben.
\end{hintbox}


\subsection{Darstellung: \inPy{__str__} und \inPy{__repr__}}
Wie Sie wissen, können wir den Inhalt einer \inPy{list} direkt mit \inPy{print} ausgeben:
\begin{codebox}[Beispiel: Ausgabe einer \texttt{list}]
\begin{minted}[linenos]{python3}
houseNumbers = [12, 21, 12, 7]  # yes, they really belong to the last four
print(houseNumbers)
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Ausgabe einer \texttt{list}]
[12, 21, 12, 7]
\end{cmdbox}

Dagegen erhalten wir für unsere Klasse so nur eine sehr unzufriedenstellende Antwort
\begin{codebox}[Beispiel: Ausgabe einer Instanz von \texttt{Expartner} mit Standard-Methode]
\begin{minted}[linenos]{python3}
# Klasse Expartner und Instanz ex wie oben
print(ex)
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Ausgabe einer Instanz von \texttt{Expartner} mit Standard-Methode]
\begin{minted}{text}
<__main__.Expartner object at 0x7f00331bc820>
\end{minted}
\end{cmdbox}

Diese Ausgabe sagt uns, dass \inPy{ex} ...
\begin{itemize}
\item eine Instanz vom Typ \inPy{Expartner} ist
\item zum Modul \inPy{__main__} gehört
\item die Speicheradresse 0x7f00331bc820 hat
\end{itemize}
Die Informationen könnten manchmal zum Debuggen nützlich sein; viel nützlicher wäre es jedoch, wenn wir so Name, Größe, Vor- und Nachzüge erfahren könnten, die sich hinter dem Symbol \inPy{ex} verbergen. Doch woher kommt überhaupt die Ausgabe, die wir im Moment sehen?

Der Befehl \inPy{print} kann eigentlich nur mit Strings umgehen. Wird ein Parameter übergeben, der nicht zur Klasse \inPy{str} gehört, ruft \inPy{print} intern automatisch die Funktion \inPy{str} auf. Diese Funktion wiederum versucht verschiedene Taktiken, eine Textdarstellung für das Objekt zu erstellen. Die erste Taktik ist dabei immer, die Magic Method \inPy{__str__} des Objekts aufzurufen.

Long story short: Wenn wir einen Dunder \inPy{__str__} zur Klasse hinzufügen, können wir eine schönere Ausgabe erreichen. Dies kann z.B. so aussehen:

\begin{codebox}[Beispiel: Ausgabe einer Instanz von \texttt{Expartner} mit eigener Methode]
\begin{minted}[linenos]{python3}
class Expartner :
    # ... Attribute wie oben ...
    # ... __init__ wie oben ...
    # ... rating wie oben ...
    
    def __str__(self) :
        reVal  = self.name + "\n"
        reVal += "  Height      : " + str(self.height)          + "\n"
        reVal += "  Upsides     : " + str(self.upsides)  [1:-1] + "\n"
        reVal += "  Downsides   : " + str(self.downsides)[1:-1] + "\n"
        reVal += "  Total Rating: " + str(self.rating())
        return reVal

ex = Expartner("Sönke" , 1.81, 
              {"intelligent", "quite handsome", "cheerful nature"},
              {"superficial", "racist"})

print(ex)
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: Ausgabe einer Instanz von \texttt{Expartner} mit eigener Methode]
\begin{minted}{text}
Sönke
  Height      : 1.81
  Upsides     : 'intelligent', 'quite handsome', 'cheerful nature'
  Downsides   : 'racist', 'superficial'
  Total Rating: -20
\end{minted}
\end{cmdbox}

Halten Sie sich vor Augen: Der Aufruf von \inPy{__str__} geschieht durch die Funktion \inPy{str}, die wiederum von \inPy{print} aufgerufen wird. Das heißt, auch wenn Sie direkt \inPy{str} benutzen, erhalten Sie den String, wie er von Ihrer Methode vorbereitet wird.

\begin{codebox}[Beispiel: \texttt{str} und Klassen]
\begin{minted}[linenos]{python3}
# Klasse Expartner und Instanz ex wie oben
text = str(ex)
lines = text.split("\n")
print(lines[0])
\end{minted}
\end{codebox}
\begin{cmdbox}[Ausgabe: \texttt{str} und Klassen]
\begin{minted}{text}
Sönke
\end{minted}
\end{cmdbox}

Natürlich können Sie den Dunder auch direkt aufrufen. Die Zeile \inPy{ex.__str__()} hat exakt dasselbe Ergebnis wie der Aufruf über \inPy{str}. Diese etwas eigenartig anmutende Konstruktion wurde gewählt, um die Logik anderer Sprachen nachzuahmen, wo eben \emph{Funktionen} zur Typ-Umwandlung benutzt werden, nicht aber \emph{Methoden}.

Ähnlich wie \inPy{__str__} wird \inPy{__repr__} über \inPy{repr} aufgerufen. Erzeugt wird der oben gezeigte Debug-String mit der Adresse der Instanz. Der Code hierfür wird automatisch mit dem Anlegen einer Klasse erstellt (mehr dazu in Abschnitt \ref{sec:Inheritance}), kann aber leicht überschrieben werden. Die Ausgabe von \inPy{repr} soll eine kompakte Darstellung des Datenobjekts enthalten, die nicht zwingend für den Enduser gedacht ist. Prinzipiell aber kann hier ein beliebiger Alternativtext zur Ausgabe von \inPy{str} erzeugt werden.

\subsection{Vergleich: \inPy{__eq__}, \inPy{__ne__}, \inPy{__gt__}, \inPy{__ge__}, \inPy{__lt__}, \inPy{__le__}}
Die Instanzen von Klassen können oft miteinander verglichen werden. Das bedeutet sowohl, dass wir die Frage stellen können, ob zwei Instanzen der Klasse denselben Wert beschreiben (\inPy{a == b}, \eg \inPy{"Wort" == "Wort"}), also auch, in welcher Reihenfolge man diese Instanzen anordnen würde, (\inPy{a < b}, \eg \inPy{"Apfel" < "Zitrone"}).

Am Beispiel von Strings hatten wir schon kennengelernt, dass Python diese \emph{lexikographisch} (\enquote{alphabetisch mit Regeln für Ziffern und Sonderzeichen}) ordnet. Im Allgemeinen gibt es aber kein \enquote{natürliches Kriterium}, nach dem Klasseninstanzen verglichen oder geordnet werden sollen. Im Kontext des Beispiels des Kapitels: Wir könnten die Instanzen von \inPy{Expartner} beispielsweise nach Körpergröße, nach dem Namen, nach Bewertung der Beziehung oder jedem beliebigen anderen Kriterium ordnen.

Wir müssen also definieren, was unter \inPy{a == b}, \inPy{a != b}, \inPy{a < b}, \inPy{a <= b}, \inPy{a > b} und \inPy{a >= b} zu verstehen ist. Wie Sie dies aus der Struktur des Kapitels vermutlich erwarten, geschieht das über die Dunders \inPy{__eq__} (equal), \inPy{__ne__} (not eqal), \inPy{__gt__} (greater than), \inPy{__ge__} (greater than or equal), \inPy{__lt__} (less than) und \inPy{__le__} (less than or equal). Die Funktionen werden aufgerufen, wenn einer der Vergleichsoperatoren an einer Instanz unserer Klasse angewandt wird. Die Methode muss neben \inPy{self} einen weiteren Parameter entgegennehmen -- die Instanz, gegen die verglichen werden  soll. Der Rückgabewert soll \inPy{True} sein, wenn die Vergleichsbedingung erfüllt ist (also \eg: die Methode \inPy{__eq__} soll \inPy{True} zurückgeben, wenn die beiden Instanzen tatsächlich gleichwertig sind), andernfalls soll das Ergebnis \inPy{False} sein.

Beispiel: da wir hier die Vergangenheit mit wissenschaftlichen Methoden aufarbeiten wollen, bietet es sich an, die Beziehungen nach der Bewertung (dem Ergebnis der Methode \inPy{rating}) zu ordnen:

\begin{codebox}[Beispiel: Implementation der Vergleichsmethoden]
\begin{minted}[linenos]{python3}
class Expartner:
    # ... Attribute wie oben ...
    # ... __init__ wie oben ...
    # ... rating wie oben ...
    
    def __eq__(self, other) :
        return (self.rating() == other.rating())
    
    def __ne__(self, other) :
        return (self.rating() != other.rating())
    
    def __lt__(self, other) :
        return (self.rating() <  other.rating())
    
    def __le__(self, other) :
        return (self.rating() <= other.rating())
    
    def __gt__(self, other) :
        return (self.rating() >  other.rating())
    
    def __ge__(self, other) :
        return (self.rating() >= other.rating())
\end{minted}
\end{codebox}

Sobald diese Magic Methods implementiert sind, können alle Operationen durchgeführt werden, die einen Vergleich benötigen:

\begin{codebox}[Beispiel: Anwendung der Vergleichsmethoden]
\begin{minted}[linenos]{python3}
# Klasse Expartner wie oben

exbfs = [
    Expartner("Sebastian", 1.65,
              {"intelligent", "handsome", "likes to listen"},
              {"obsessed with catching bugs", "always late"}),
    Expartner("Reginald", 1.84,
              {"very intelligent", "handsome", "plays in a band"},
              {"flirty with everyone", "complains a lot"}),
    Expartner("Sönke", 1.81,
              {"intelligent", "quite handsome", "cheerful nature"},
              {"superficial", "racist"})]
\end{minted}
\end{codebox}
%
\begin{codebox}[]
\begin{minted}[linenos, firstnumber=last]{python3}
exgfs = [
    Expartner("Steffie", 1.65, 
              {"intelligent", "beautiful", "has a dog"},
              {"too attached to her mother", "doesn't like meeting people"}),
    Expartner("Arista" , 1.60,
              {"very intelligent", "beautiful", "good taste in music"},
              {"doesn't like coding", "doesn't like coffee"}),
    Expartner("Katja"  , 1.81,
              {"intelligent", "very beautiful", "musician"},
              {"moody", "cheated on me"})
    ]

if exbfs[0] < exbfs[1] :
    print(f"It was better with {exbfs[1].name} than with {exbfs[0].name}")
else :
    print(f"It was better with {exbfs[0].name} than with {exbfs[1].name}")

print("All of them, from worst to best")
allExes = sorted(exgfs + exbfs)
for ex in allExes :
    print(ex)
\end{minted}
\end{codebox}

Beachten Sie zuerst Zeile 25: Wir vergleichen \emph{direkt} Instanzen der Klasse \inPy{Expartner}. Natürlich wäre es immer noch möglich, zu fragen ob \inPy{exbfs[0].rating() < exbfs[1].rating()}. Diese Bedingung hätte in Zeile 25 exakt denselben Effekt. Diese explizite Angabe können Sie sich von hier weg aber sparen. Durch die Implementation von \inPy{__eq__} etc. \enquote{weiß} Python, nach welchen Regeln ein Vergleich stattzufinden hat. Natürlich hätte es wenig Sinn, diese sechs Methoden zu implementieren, wenn diese nur an einer einzigen Stelle verwendet werden (wie in diesem Beispiel). Im Allgemeinen aber werden Sie Klassen und Instanzen in sehr viel größeren Kontexten verwenden, und gewinnen so signifikant Komfort.

Ein weiterer Vorteil der Verwendung dieser Duders liegt darin, dass viele Funktionen \enquote{in ihrem Inneren} Vergleiche durchführen, und damit natürlich nur anwendbar sind, wenn der notwendige Vergleich klar definiert ist. Dies gilt zum Beispiel für die Funktion \inPy{sorted}. Wie Sie sich aus Kapitel \ref{chp:Containers} erinnern (und wie der Name vermuten lässt), wird dieser Befehl benutzt, um Datencontainer zu sortieren. Um diese Aufgabe zu erledigen, führt \inPy{sorted} für Elemente \inPy{a, b} des Containers jeweils Vergleiche \inPy{a < b}, ... durch. Ohne die Dunders, die wir gerade besprechen, wäre das nicht möglich. Natürlich könnten wir immer noch ein Lambda übergeben, das das Ergebnis von \inPy{rating} als Sortierkriterium markiert (vgl. Hierzu Kapitel \ref{chp:Funcs}). Durch die hier gewählte Methode erhalten wir aber die Wahl des Sortierkriteriums automatisch.

Mit diesen Überlegungen verstehen Sie, weshalb wir die folgende Ausgabe erhalten:

\begin{cmdbox}[Ausgabe: Anwendung der Vergleichsmethoden]
\begin{minted}{text}
It was better with Sebastian than with Reginald
All of them, from worst to best
Sönke
  Height      : 1.81
  Upsides     : 'intelligent', 'cheerful nature', 'quite handsome'
  Downsides   : 'racist', 'superficial'
  Total Rating: -20
Katja
  Height      : 1.81
  Upsides     : 'intelligent', 'very beautiful', 'musician'
  Downsides   : 'moody', 'cheated on me'
  Total Rating: -10
Steffie
  Height      : 1.65
  Upsides     : 'intelligent', 'has a dog', 'beautiful'
  Downsides   : "doesn't like meeting people", 'too attached to her mother'
  Total Rating: 4
Reginald
  Height      : 1.84
  Upsides     : 'very intelligent', 'handsome', 'plays in a band'
  Downsides   : 'flirty with everyone', 'complains a lot'
  Total Rating: 5
Sebastian
  Height      : 1.65
  Upsides     : 'intelligent', 'likes to listen', 'handsome'
  Downsides   : 'obsessed with catching bugs', 'always late'
  Total Rating: 7
Arista
  Height      : 1.6
  Upsides     : 'good taste in music', 'very intelligent', 'beautiful'
  Downsides   : "doesn't like coffee", "doesn't like coding"
  Total Rating: 10
\end{minted}
\end{cmdbox}

Beachten Sie, dass der \emph{Datentyp} der zu vergleichenden Objekte eine wesentliche Rolle spielt: die beiden folgenden Beispiele werden jeweils mit Fehlermeldung abgebrochen:

\begin{minipage}{.49\linewidth}
\begin{warnbox}[Beispiel: Inkompatible Datentypen (1), leftupper=7mm]
\begin{minted}[linenos]{python3}
# Expartner, allExes wie oben
print(allExes[0] < 0)
\end{minted}
\end{warnbox}
\end{minipage}
%
\begin{minipage}{.49\linewidth}
\begin{warnbox}[Beispiel: Inkompatible Datentypen (2), leftupper=7mm]
\begin{minted}[linenos]{python3}
# Expartner, allExes wie oben
print(0 > allExes[0])
\end{minted}
\end{warnbox}
\end{minipage}

In beiden Fällen erhalten Sie die Fehlermeldung:
\begin{cmdbox}[Fehlermeldung: Inkompatible Datentypen (1)]
\begin{minted}{text}
...
AttributeError: 'int' object has no attribute 'rating'
\end{minted}
\end{cmdbox}

Durchdenken wir zuerst das Beispiel: Inkompatible Datentypen (1). Der Ausdruck \inPy{allExes[0] < 0} wird also übersetzt in einen Aufruf der Methode \inPy{Expartner.__lt__(allExes[0], 0)}, \ie \inPy{allExes[0]} wird als erster Parameter \inPy{self} übergeben, und \inPy{0} ist der Wert von \inPy{other}. Damit ist \inPy{other} also vom Typ \inPy{int} und hat folglich auch keine Methode \inPy{rating} -- diese Methode ist nur für Instanzen der Klasse \inPy{Expartner} erklärt. Damit ist auch die Fehlermeldung für diesen Fall verständlich. Sie als ProgrammiererIn müssen also entweder darauf achten, nur \enquote{sinnvolle} Vergleiche anzufordern, oder aber in den Dunders \inPy{__eq__}, ... verschiedene Vergleichsmethoden für verschiedene Datentypen anzubieten. Hierzu können Sie beispielsweise den folgenden Ansatz wählen:

\begin{codebox}[Beispiel: Typabhängige Vergleichsmethoden]
\begin{minted}[linenos]{python3}
class Expartner:
    # ... Attribute wie oben ...
    # ... rating wie oben ...
    
    def __eq__(self, other) :
        if type(other) in (int, float) : return self.rating() == other
        if type(other) == Expartner    : return self.rating() == other.rating()
        return NotImplemented
    
    # andere Vergleichsmethoden ...
\end{minted}
\end{codebox}

Wie Sie sich erinnern, erhalten Sie mit der Funktion \inPy{type} den Datentypen einer Variablen. Dabei ist es nicht von Belang, ob es sich um einen \enquote{eingebauten} (nativen) Datentypen wie \inPy{int} handelt, oder um eine von Ihnen erstellte Klasse. Mit diesem Hilfsmittel können Sie nun also abhängig von der \enquote{Beschaffenheit} von \inPy{other} also unterschiedliche Vergleichsmethoden anbieten, die allesamt über die üblichen Vergleichsoperatoren (\inPy{==}, \inPy{<}, ...) genutzt werden können.

Neu ist an dieser Stelle der Rückgabewert \inPy{NotImplemented}; dieser führt auch direkt zum Beispiel: Inkompatible Datentypen (2).

Bei den Vergleichen wie \inPy{a < b} wird implizit das linke Element (also \inPy{a}) als \emph{Basisklasse des Vergleichs} herangezogen. Das heißt, dass die Vergleichsmethode (\inPy{__lt__}) in der Klasse gesucht wird, von der \inPy{A} eine Instanz ist. Damit wird \inPy{a} als \inPy{self} übergeben, während \inPy{b} als \inPy{other} an die Methode weitergeleitet wird.

Der Vergleich \inPy{0 > allExes[0]} würde also zuerst die Methode \inPy{__lt__} der Klasse \inPy{int} aufrufen, und zwar mit \inPy{0} als \inPy{self} und mit \inPy{allExes[0]} als \inPy{other}. Wie Sie sich vorstellen können, hatten die Entwickler von Python nicht vorhergesehen, dass ich im Rahmen dieses Kurses eine Vergleichsmethode von \inPy{int}s und \inPy{Expartner}s benötige. Stattdessen sind nur die Vergleiche zu den \enquote{in Python eingebauten} Datentypen implementiert. Für jeden anderen Datentyp wird zunächst der Fehlerwert \inPy{NotImplemented} zurückgegeben.

Die interne Mechanik des Python-Interpreters reagiert genau auf dieses Signal: Wenn eine Vergleichsmethode zu \inPy{NotImplemented} ausgewertet wird, so zieht der Interpreter das rechtsseitige Vergleichsobjekt (das \inPy{b} in \inPy{a < b}) heran, und versucht hier eine geeignete Vergleichsmethode zu finden. Erst wenn dies fehlschlägt (\ie wenn auch die Klasse von \inPy{b} den Wert \inPy{NotImplemented} zurück gibt), \enquote{gibt der Python-Interpreter auf}. Sie finden die Fehlermeldung
\begin{cmdbox}[Fehlermeldung: Inkompatible Datentypen (2)]
\begin{minted}{text}
TypeError: '<' not supported between instances of 'Expartner' and 'int'
\end{minted}
\end{cmdbox}

Wenn Sie also die Klassen \inPy{Apple} und \inPy{Orange} schreiben, sollte ein \inPy{Apple} wissen, wie er sich mit einem anderen \inPy{Apple} vergleicht; auch eine \inPy{Orange} muss wissen, wie sie sich mit einer \inPy{Orange} vergleicht. Es reicht aber, in \inPy{Orange} den Vergleich mit \inPy{Apple} zu implementieren. \inPy{Apple} selbst kann sich mit einem \inPy{NotImplemented} begnügen\footnote{Dies scheint auch die Denkweise des Konzerns zu sein...}.

\subsection{Gebrauch als Funktion: \inPy{__call__}}
Klasseninstanzen können auch als Funktionen gebraucht werden. Über die Syntax:
\begin{codebox}[Syntax: Aufruf einer Instanz]
\begin{minted}[linenos]{python3}
Instanz(Parameterliste)
\end{minted}
\end{codebox}

wird der Dunder \inPy{__call__(self, Parameterliste)} aufgerufen. Wie bei allen Methoden darf die Parameterliste auch leer sein, Default-Werte annehmen und/oder variadische Elemente enthalten. Konkret kann dies so aussehen:

\begin{codebox}[Beispiel: Aufrufbare Instanzen]
\begin{minted}[linenos]{python3}
class Expartner :
    # wie oben
    
    def __call__(self) :
        print("You shouldn't call your Ex'es. Leave the past behind.")

ex = Expartner("Sandra", 1.70)
ex()
\end{minted}
\end{codebox}

Dies kann etwa nützlich werden, wenn eine Funktion sehr viele Parameter bräuchte, wenn die Werte dieser Parameter sich durch den Code der Funktion verändern und im Nachhinein erhalten bleiben sollen, oder eine thematische Einheit bilden. Sie können sich etwa ein kleines Spiel vorstellen: Das Spiel muss zuerst konfiguriert werden (Schwierigkeitsgrad, Größe des Spielfelds, Spielerzahl, ...), bevor es gestartet werden kann. In diesem Fall ist es ein sinnvolles Programmdesign, eine Klasse \inPy{Game} zu erstellen, die alle diese Daten als Attribute verwaltet. Von dieser Klasse wird eine Instanz \inPy{match} erstellt. Sind (\eg über ein geeignetes User-Interface) alle Werte sinnvoll festgelegt, so kann die Instanz \inPy{match} gestartet, \ie aufgerufen werden. Nach Ende der Partie steht das Objekt \inPy{match} weiter zur Verfügung, und kann \eg für eine Highscore-Liste ausgewertet werden.

\subsection{Rechenoperatoren: \inPy{__add__}, \inPy{__sub__}, \inPy{__mul__}, \inPy{__truediv__}, \inPy{__floordiv__}, \inPy{__matmul__}}
Mit Instanzen von Klassen kann auch gerechnet werden wie mit \enquote{normalen Zahlen}. Natürlich ist dies nicht immer sinnvoll; beispielsweise habe ich keine Idee, welche Bedeutung dem Ausdruck\\
\inPy{CharlottesLastEx - MyLastEx} zukommen sollte. Daher möchte ich Sie darum bitten, sich für die folgenden Abschnitte in ein neues Beispiel einzudenken. Wir werden hier \emph{Matrizen} wie aus der Mathematik bekannt behandeln.

Eine Matrix ist eine Sammlung von Werten, die in einer rechteckigen Tabelle angeordnet sind, \ie eine Sammlung von Zeilen, wobei jede Zeile eine Sammlung von gleich vielen Zahlen ist. Eine Matrix lässt sich also als \emph{Liste von Listen} abbilden. Um eine Matrix als Klasse abzubilden, ist es also sinnvoll, ein Attribut \inPy{data} zu definieren, das diese Liste von Listen beinhaltet.

Bei der Arbeit mit Matrizen ist es auch wichtig, die Größe der Matrix zu kennen. Beispielsweise ist die Matrixmultiplikation nur dann möglich, wenn die Zahl der Spalten der linken Matrix mit der Zahl der Zeilen der rechten Matrix zusammenfällt. Wir können mit \inPy{len} diese Information (Zeilenzahl und Spaltenzahl) in Erfahrung bringen. Wir wollen daher diese Information als Attribut \inPy{shape} in einem \inPy{tuple} speichern. (Ebenso könnten wir zwei \inPy{int}-Attribute \inPy{rows, cols} verwenden. Vorlieben variieren.)

Jede Instanz von \inPy{Matrix} braucht seine eigenen Attribute \inPy{data, shape}. Es gibt keine Zahlen, die sich alle Matrizen teilen. Daher werden wir die genannten Attribute nicht direkt nach dem Header \inPy{class Matrix} anlegen, sondern erst in der Methode \inPy{__init__}. Sie erinnern sich: Diese Methode wird aufgerufen, sobald eine neue Instanz angelegt wird. Wenn wir hier Attribute einpfelgen, sorgen wir auch dafür, dass sie rein an die Instanz gebunden sind. Komplikationen wie im \emph{Beispiel: Versehentliches Verändern von Referenzen} werden so vermieden.

Wenn wir eine neue Matrix anlegen, müssen wir ihre Größe und ihren Inhalt festlegen. Es gibt aber häufig Situationen, in denen wir die Matrixwerte erst Stück für Stück aufbauen können. Daher soll es auch möglich sein, eine \enquote{leere Matrix} mit fester Größe zu erstellen. Diese \enquote{leere Matrix} füllen wir mit Nullen auf. Wenn dagegen alle Werte schon bekannt sind, so wollen wir eine Liste von Listen als Parameter entgegen nehmen können und diese in unsere Matrix-Struktur einpflegen können.

Mit diesen Überlegungen können wir den folgenden Code schreiben:
\begin{codebox}[Beispiel: Klasse Matrix]
\begin{minted}[linenos]{python3}
import copy

class Matrix :
    def __init__(self, shape, data = None) :
        # check for validity of shape parameter
        if type(shape) != tuple         :
            raise Exception("Expected a tuple!")
        if len (shape) != 2             :
            raise Exception("Expected a 2-tuple!")
        if shape[0] < 1 or shape[1] < 1 :
            raise Exception("Expected positive values")
        
        self.shape = shape
        
        if data == None :
            # fill with zeros
            self.data  = []
            for     row in range(shape[0]) :
                self.data.append([])
                for col in range(shape[1]) :
                    self.data[row].append(0)
        else :
            self.setData(data)
\end{minted}
\end{codebox}
\begin{codebox}[]
\begin{minted}[linenos,firstnumber=last]{python3}
    def setData(self, data) :
        if type(data)    != list : raise Exception("Expected a list of lists")
        if type(data[0]) != list : raise Exception("Expected a list of lists")
        
        rows = len(data)
        cols = len(data[0])
        
        # check if all provided rows have same length
        for row in data :
            if len(row) != cols : raise Exception("Ill-formed matrix")
        
        self.shape = (rows, cols)
        self.data  = copy.deepcopy(data)
\end{minted}
\end{codebox}

Zuerst testen wir, ob die angegebene \inPy{shape} in unserem Kontext sinnvoll ist. Falls nein, brechen wir mit Fehlermeldung ab (Zeilen 6-11). 

In Zeile 14 übertragen wir die Daten des Parameters \inPy{shape} in das Attribut \inPy{self.shape}. Lassen Sie sich nicht von den gleichen Namen verwirren: \inPy{shape} kommt \enquote{von außen} und ist nicht dasselbe wie das Attribut \inPy{self.shape}, das zur Matrix gehört. Da wir hier mit \inPy{tuple}s arbeiten (die immutable sind), ist eine versehentliche Veränderung der Werte ausgeschlossen. Wir können ohne weiteres die Referenz übernehmen.

In den Zeilen 17-21 erzeugen wir eine Null-Matrix der angeforderten Größe. In eine leere Liste fügen wir zunächst leere Listen (Zeilen) ein, die wir im Anschluss mit Nullen auffüllen.

Der Parameter \inPy{data} enthält gegebenenfalls Werte, die in die Matrix eingetragen werden sollen. Falls wir beim Anlegen der Instanz keine Daten bereit haben, können wir dies durch \inPy{data = None} signalisieren. Es könnte auch sein, dass wir die Werte einer bestehenden Matrix später updaten wollen, ohne die Matrix selbst komplett neu anzulegen. Daher lagern wir das Befüllen mit Werten in eine eigene Methode aus, und rufen von \inPy{__init__} diese Methode \inPy{setData} auf (Zeile 23).

In \inPy{setData} prüfen wir wieder zunächst den Datentypen (Liste von Listen; Zeile 25-26), und dann, ob die übergebenen Werte auf tatsächlich eine rechteckige Matrix beschreiben (Zeile 31-35). Um nicht versehentlich Referenzen zu übernehmen, benutzen wir \inPy{copy.deepcopy}, um die Werte in unsere Matrix zu übernehmen.

Schon um zu testen, ob unsere Methoden so funktionieren, wie wir das wollen, fügen wir noch die Dunders \inPy{__str__} und \inPy{__repr__} hinzu:

\begin{codebox}[]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __repr__(self) :
        return f"<matrix of dimension {self.shape[0]}x{self.shape[1]}>"
    
    def __str__(self) :
        reVal = ""
        for row in self.data :
            reVal += str(row) + "\n"
        return reVal[:-1]               # remove superfluous line break
\end{minted}
\end{codebox}

Nachdem wir so kurz wiederholt haben, wie wir eine Klasse konzipieren und ihr vier Methoden hinzugefügt haben, können wir uns nun der Aufgabe stellen, das Rechnen mit Matrizen zu implementieren. Wenn \inPy{A} und \inPy{B} Instanzen von \inPy{Matrix} sind, so wollen wir, dass Ausdrücke wie \inPy{A + B} korrekt ausgewertet werden. Zu diesem Zweck schreiben wir für jeden Operator einen speziellen Dunder. Im Falle der Addition ist das \inPy{__add__}:

\begin{codebox}[Beispiel: Methode \texttt{\_\_add\_\_}]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __add__(self, other) :
        if type(other) != Matrix      : return NotImplemented
        if self.shape  != other.shape : raise Exception("Incompatible matrices")
        
        reVal = Matrix(self.shape)
        
        for     row in range(self.shape[0]) :
            for col in range(self.shape[1]) :
                reVal.data[row][col] = self.data[row][col] + other.data[row][col]
        return reVal
\end{minted}
\end{codebox}

Wie bei den Vergleichsoperatoren (\inPy{__eq__}, ...) bezieht sich \inPy{self} auf das Symbol links des Operators (also auf \inPy{A} in \inPy{A + B}), während \inPy{other} eine Referenz auf das rechte Symbol (\inPy{B}) erhält.

Wir prüfen wieder, ob der Datentyp des rechten Operanden (\inPy{B}) geeignet ist (Zeile 46). Falls nein geben wir den Fehlerwert \inPy{NotImplemented} zurück, der Python die Chance gibt, verschiedene Fehlerbehandlungsmethoden anzuwenden. (Wir werden dies im nächsten Punkt besprechen). Falls die Größen der Matrizen nicht aufeinander passen, brechen wir das Programm mit einer Fehlermeldung ab (Zeile 47).

Für die eigentliche Rechnung müssen wir eine neue Matrix bereit stellen, die das Ergebnis aufnimmt (Zeile 49). In diese können wir jetzt jeweils die komponentenweise Summe eintragen (Zeilen 51-53). Schließlich muss dieses so gefundene Ergebnis auch der aufrufenden Stelle mitgeteilt werden -- wir schließen also mit einer \inPy{return}-Zeile ab (Zeile 54).

Das Zeichen \inPy{*} wird durch einen Aufruf der Methode \inPy{__mul__} aufgelöst. Hier wollen wir die \emph{komponentenweise} Matrixmultiplikation sowie die Multiplikation mit einem Skalar umsetzen:

\begin{codebox}[Beispiel: Methode \texttt{\_\_mul\_\_}]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __mul__(self, other) :
        reVal = Matrix(self.shape)
        
        if type(other) == Matrix :
            if self.shape  != other.shape :
                raise Exception("Incompatible matrices")
            
            for     row in range(self.shape[0]) :
                for col in range(self.shape[1]) :
                    reVal.data[row][col] = self .data[row][col] * \
                                           other.data[row][col]
            
            return reVal
\end{minted}
\end{codebox}
\begin{codebox}[]
\begin{minted}[linenos,firstnumber=last]{python3}
        elif type(other) in (int, float, complex) :
            for     row in range(self.shape[0]) :
                for col in range(self.shape[1]) :
                    reVal.data[row][col] = self.data[row][col] * other
            
            return reVal
        
        else :
            return NotImplemented
\end{minted}
\end{codebox}

Hier finden wir dieselbe Grundstruktur wie schon bei \inPy{__add__} wieder: Vorbereiten einer Ergebnis-Variable \inPy{reVal}, Typenprüfung, Schrittweiser Aufbau der Lösung, und \enquote{Abschicken} der Lösung mit \inPy{return} bzw. Zurückgeben des Fehlerwertes \inPy{NotImplemented}, wenn bei der Typenprüfung ein Fehler aufgetreten ist.

Da wir durch die Multiplikation mit dem Skalar \inPy{-1} jetzt auch das Vorzeichen jeder Matrix-Komponente umdrehen können, lassen sich die Subraktion (\inPy{__sub__}) und die \emph{exakte Division} (\inPy{__truediv__}) mit sehr geringem Aufwand schreiben:

\begin{codebox}[Beispiel: Methoden \texttt{\_\_sub\_\_} und \texttt{\_\_truediv\_\_}]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __sub__(self, other) :
        return self + (other * -1)
    
    def __truediv__(self, other) :
        return self * (1 / other)
\end{minted}
\end{codebox}

Für die \emph{Integerdivision} (Division mit Abrunden, \inPy{__floordiv__}) dagegen müssen wir unser übliches Schema anwenden:

\begin{codebox}[Beispiel: Methode \texttt{\_\_floordiv\_\_}]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __floordiv__(self, other) :
        if type(other) in (int, float, complex) :
            for     row in range(self.shape[0]) :
                for col in range(self.shape[1]) :
                    reVal.data[row][col] = self.data[row][col] // other
            
            return reVal
        
        else :
            return NotImplemented
\end{minted}
\end{codebox}

Vielleicht haben Sie sich schon zuvor gewundert, dass wir die Methode \inPy{__mul__} \emph{komponentenweise} implementiert haben. Für die übliche Matrix-Multiplikation 
\begin{equation*}
	(AB)_{ij} = \sum_{k} A_{ik} B_{kj}
\end{equation*}
ist nämlich der Dunder \inPy{__matmul__} vorgesehen. Dieser wird über den Operator \inPy{@} aufgerufen:

\begin{codebox}[Beispiel: Methode \texttt{\_\_floordiv\_\_}]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __matmul__(self, other) :
        if type(other) == Matrix :
            if other.shape[0] != self.shape[1] :
                raise Exception("Incompatible Shapes")
            resultShape = (self.shape[0], other.shape[1])
            result = Matrix(resultShape)
            
            for         i in range(resultShape[0]) :
                for     j in range(resultShape[1]) :
                    for k in range(other.shape[0]) :
                        result.data[i][j] += self.data[i][k] * other.data[k][j]
            return result
        return NotImplemented
\end{minted}
\end{codebox}

Natürlich sollten wir unsere Methoden auch testen:

\begin{codebox}[Beispiel: Tests einiger Methoden]
\begin{minted}[linenos,firstnumber=last]{python3}
A = Matrix((2,2), [[1,2], [3,4]])
B = Matrix((2,3), [[9,8,7], [6,5,4]])

print("A")
print( A )
print("B")
print( B )

print("A + A")
print( A + A )

print("A * A")
print( A * A )

print("A @ B")
print( A @ B )
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Tests einiger Methoden]
\begin{minted}{text}
A
[1, 2]
[3, 4]
B
[9, 8, 7]
[6, 5, 4]
A + A
[2, 4]
[6, 8]
A * A
[1, 4]
[9, 16]
\end{minted}
\end{cmdbox}
%
\begin{cmdbox}[]
\begin{minted}{text}
A @ B
[21, 18, 15]
[51, 44, 37]
\end{minted}
\end{cmdbox}

\subsection{Rechtsseitige Rechenoperatoren: \inPy{__radd__}, \inPy{__rsub__}, \inPy{__rmul__}, \inPy{__rtruediv__}, \inPy{__rfloordiv__}}
Im Moment können wir zwar für eine \inPy{Matrix A} den Ausdruck \inPy{A * 2} berechnen; für \inPy{2 * A} dagegen erhalten wir noch die Fehlermeldung
\begin{cmdbox}[Fehlermeldung: Multiplikation mit Skalar von links]
\begin{minted}{text}
Traceback (most recent call last):
  File "matrix.py", line 139, in <module>
    print( 2 * A )
TypeError: unsupported operand type(s) for *: 'int' and 'Matrix'
\end{minted}
\end{cmdbox}

Um dies zu verstehen, erinnern wir uns, dass durch den Operator \inPy{*} die Methode \inPy{__mul__} des \emph{linken} Objekts aufgerufen wird, also hier der \inPy{int}-Instanz \inPy{2}. Natürlich \enquote{weiß \inPy{int} nicht}, wie es mit Matrizen umzugehen hat, und gibt damit den Fehlerwert \inPy{NotImplemented} zurück, der hier zu dieser Fehlermeldung führt. Bevor Python aber \enquote{aufgibt}, versucht der Interpreter, die Methode \inPy{__rmul__} des \emph{rechten} Operanden (also \inPy{A}) aufzurufen.

Fügen wir also in unserer Klassen-Definition von \inPy{Matrix} noch folgende Zeilen ein:
\begin{codebox}[Beispiel: Tests einiger Methoden]
\begin{minted}[linenos,firstnumber=105]{python3}
    def __rmul__(self, other) :
        return self * other
\end{minted}
\end{codebox}

so kann Python auch \inPy{2 * A} berechnen: für die Methode \inPy{__rmul__} verweist der Parameter \inPy{other} auf den \emph{linken} Operanden (also die \inPy{2}). Wir haben hier die Reihenfolge des Ausdrucks umgedreht, und können so den schon bestehenden Code von \inPy{__mul__} ausnutzen.

Ähnlich wie für die Multiplikation existieren auch rechtsseitige Methoden für die Addition, Subtraktion, Fließkomma- und Ganzzahldivision (\inPy{__radd__}, \inPy{__rsub__}, \inPy{__rtruediv__}, und \inPy{__rfloordiv__}). Alle diese Methoden haben dasselbe Verhalten, \ie sie werden aufgerufen, nachdem ihr linksseitiges Pendant \inPy{NotImplemented} zurückgegeben hat.


\subsection{Index-Zugriff: \inPy{__getitem__}, \inPy{__setitem__}}
Wir wollen auch einzelne Matrixelemente lesen und schreiben können, so wie wir auch bei \inPy{list}s etc. Elemente aus der Liste herausgereifen können. Zum \emph{Lesen} von einzelnen Werten dient der Dunder \inPy{__getitem__}. Neben dem obligatorischen \inPy{self} muss die Methode einen Index annehmen, und soll das durch diesen Index bezeichnete Objekt zurück geben. Wie wir das von \inPy{list}s kennen, geschieht der lesende Index-Zugriff über die Syntax \inPy{Instanz[Index]}.

Klassischerweise versteht man unter einem Index eine einzige Ganzzahl; es spricht aber nichts dagegen, hier andere Datentypen auch zu verwerten. Da eine Matrix ein \emph{zweidimensionales} Objekt ist, könnten wir auch einen Tupel aus zwei Werten akzeptieren. Wenn \inPy{A} also eine Instanz von \inPy{Matrix} ist, so soll \inPy{A[1,2]} also das Matrixelement in der \emph{zweiten} Zeile und der \emph{dritten} Spalte ansprechen. (Die Zählung beginnt wie immer bei der Null).

Falls tatsächlich nur eine einzelne Zahl übergeben wird, so ist es sinnvoll, diese als \emph{Zeilenindex} aufzufassen, und die ganze Zeile der Matrix zurück zu geben. Dies kann aus unserer gewählten Struktur heraus leicht implementiert werden, und hat den weiteren Vorteil, dass Konstrukte wie \inPy{A[row][column]} immer noch funktionieren. Hierbei wird zuerst \inPy{A[row]} ausgewertet und gibt dann eine \inPy{list} zurück; auf diese Liste wird dann wieder der Indexzugriff mit index \inPy{column} ausgewertet.

Eine Implementierung dieser Gedanken kann so aussehen:

\begin{codebox}[Beispiel: Lesender Indexzugriff]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __getitem__(self, index) :
      if type(index) == int :
        if 0 <= index < self.shape[0] :
          return self.data[index]
        else :
          raise Exception("Invalid Index")
        
      elif type(index) == tuple :
        if len(index) != 2 : raise Exception("Invalid Dimension")
        
        row = index[0]
        col = index[0]
        
        if (0 <= row < self.shape[0]) and (0 <= col < self.shape[1]) :
          return self.data[row][col]
        else :
          raise Exception("Invalid Index")
      
      else :
        raise Exception("Invalid Index")
\end{minted}
\end{codebox}

Ähnlich Funktioniert der Dunder \inPy{__setitem__}, der aufgerufen wird, wenn über die Syntax\\
\inPy{Instanz[Index] = Ausdruck} ein Wert gesetzt werden soll. Neben den zuvor schon genannten Parametern \inPy{self} und \inPy{index} ist hier natürlich ein dritter Parameter \inPy{value} vonnöten. Einen Rückgabewert gibt es bei der Wertzuweisung dagegen nicht.

Wir wollen auch hier der Logik folgen, dass sowohl \inPy{int}-Werte als auch \inPy{tuple}s akzeptiert werden sollen. Entsprechend implementieren wir die Methode folgendermaßen:

\begin{codebox}[Beispiel: Schreibender Indexzugriff]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __setitem__(self, index, value) :
      if type(index) == int :
        if type(value) != list          : raise Exception("Invalid Data Type")
        if len (value) != self.shape[1] : raise Exception("Invalid Dimension")
        
        if 0 <= index < self.shape[0] :
          self.data[index] = value
        else :
          raise Exception("Invalid Index")
        
      elif type(index) == tuple :
        if len(index) != 2 : raise Exception("Invalid Dimensionality")
        row = index[0]
        col = index[0]
        
        if (0 <= row < self.shape[0]) and (0 <= col < self.shape[1]) :
          self.data[row][col] = value
        else :
          raise Exception("Invalid Index")
        
      else :
        raise Exception("Invalid Index")
\end{minted}
\end{codebox}

Mit diesen Ergänzungen zu unserer Klasse sind uns nun folgende Zugriffe möglich:
\begin{codebox}[Beispiel: Tests -- Indexzugriff]
\begin{minted}[linenos,firstnumber=last]{python3}
A = Matrix( (2,2) )
A[0] = [1, 2]
A[1, 1] = 4
print(A)
print(A[0, 1])
print(A[1])
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Tests -- Indexzugriff]
\begin{minted}{text}
[1, 2]
[0, 4]
1
[0, 4]
\end{minted}
\end{cmdbox}

\begin{hintbox}[Slices]
Aus Kapitel \ref{chp:Containers} kennen Sie das Konzept Slicing. Sie können Ihren Klassen ähnliche Fähigkeiten beibringen, wenn Sie den Datentyp \inPy{slice} als Parameter akzeptieren. Es handelt sich also um Instanzen der Klasse \inPy{slice}, die unter anderem die Attribute \inPy{start}, \inPy{step} und \inPy{step} haben.

Experimentieren Sie damit herum!
\end{hintbox}

\subsection{Zahl der Elemente: \inPy{__len__}}
Ähnlich wie \inPy{str} leitet auch der Befehl \inPy{len} nur auf den Dunder \inPy{__len__} um, der in jeder Klasse implementiert werden kann. Der Rückgabewert sollte ein \inPy{int}-Wert sein, der sich als Anzahl von Elementen interpretieren lässt. In unserem Fall ist also eine sinnvolle Implementierung:

\begin{codebox}[Beispiel: \texttt{\_\_len\_\_}]
\begin{minted}[linenos,firstnumber=149]{python3}
    def __len__(self) :
      return self.shape[0] * self.shape[1]
\end{minted}
\end{codebox}


\subsection{Absolutbetrag: \inPy{__abs__}}
Die Funktion \inPy{abs} berechnet den \emph{Absolutbetrag} eines Objekts, indem sie das Ergebnis des Dunders \inPy{__abs__} weiterleitet.
Was der Absolutbetrag einer Klasseninstanz ist, hängt sehr stark vom Kontext ab (und oft genug ist das Konzept überhaupt nicht anwendbar). Im Fall von Matrizen kann Beispielsweise die \emph{Maximumsnorm} berechnet werden, also das größte Element der Matrix selbst:

\begin{codebox}[Beispiel: \texttt{\_\_abs\_\_}]
\begin{minted}[linenos,firstnumber=last]{python3}
    def __abs__(self) :
      return max( [max(line) for line in self.data] )
\end{minted}
\end{codebox}


\section{Vererbung}
\label{sec:Inheritance}
In größeren Projekten werden wir in die Situation kommen, dass sich Klassen stark ähneln, aber nicht in allen Details gleich sind. In dem Beispiel der Exfreundinnen: nur von manchen kann ich mich noch an die Augenfarbe erinnern. Wir wissen, dass wir zu jeder Instanz dynamisch Attribute hinzufügen können. Dies ändert natürlich nichts daran, wie die Methoden ausgeführt werden (und soll auch nichts daran ändern). Jedoch wäre es schön, wenn die Methode \inPy{__str__} diese zusätzliche Information Augenfarbe mit ausgegeben würde.

Natürlich können wir eine zweite Klasse \inPy{ExpartnerWithEyeColor} anlegen, und allen Code der Klasse \inPy{Expartner} kopieren. Dies hätte aber auch den Effekt, dass Weiterentwicklungen an der Klasse \inPy{Expartner} doppelt gemacht werden müssen, also auch in \inPy{ExpartnerWithEyeColor} manuell eingepflegt werden müssen.

Die Technik \emph{Vererbung} erlaubt uns, dies zu umgehen oder zu automatisieren. Von einer \emph{Basisklasse} wird eine Kopie angelegt, die wir \emph{abgeleitete Klasse} nennen. Diese Klasse hat zunächst alle Eigenschaften (\ie Attribute und Methoden) der Basisklasse. Definitionen innerhalb der abgeleiteten Klasse erweitern diese gegenüber der Basisklasse, oder überschreibt die Eigenschaften, die von der Basisklasse schon gegeben waren.

Wir erreichen dies mit einem neuen Syntaxelement bei der Definition einer Klasse:
\begin{codebox}[Syntax: Abgeleitete Klassen]
\begin{minted}{python3}
class Abgeleitete_Klasse(Basisklasse)  :
    neues_Attribut = Standardwert
    ...
    def neue_Methode(self, ...) :
        ...
\end{minted}
\end{codebox}

In unserem Beispiel wollten wir der abgeleiteten Klasse \inPy{ExpartnerWithEyeColor} ein Attribut \inPy{eyeColor} hinzufügen, und die Methode \inPy{__str__}  überarbeiten. Wir erreichen dies mit den folgenden Zeilen:

\begin{codebox}[Beispiel: Abeleitete Klasse]
\begin{minted}[linenos]{python3}
# Klasse Expartner wie oben

class ExpartnerWithEyeColor(Expartner) :
    eyeColor = None
        
    def __str__(self) :
        reVal  = self.name + "\n"
        reVal += "  Height      : " + str(self.height)          + "\n"
        reVal += "  Upsides     : " + str(self.upsides)  [1:-1] + "\n"
        reVal += "  Downsides   : " + str(self.downsides)[1:-1] + "\n"
        reVal += "  Total Rating: " + str(self.rating())        + "\n"
        reVal += "  Eye Color   : " + str(self.eyeColor)
        return reVal

ex = ExpartnerWithEyeColor("Reginald", 1.84,
                          {"very intelligent", "handsome", "plays in a band"},
                          {"flirty with everyone", "complains a lot"})
ex.eyeColor = "blue"
print(ex)
\end{minted}
\end{codebox}

\begin{cmdbox}[Ausgabe: Abeleitete Klasse]
\begin{minted}{text}
Reginald
  Height      : 1.84
  Upsides     : 'very intelligent', 'handsome', 'plays in a band'
  Downsides   : 'flirty with everyone', 'complains a lot'
  Total Rating: 5
  Eye Color   : blue
\end{minted}
\end{cmdbox}

Durch das \inPy{(Expartner)} in Zeile 3 werden alle Attribute und Methoden von \inPy{Expartner} kopiert. Wir können also auch neue Instanzen mit \inPy{ex = ExpartnerWithEyeColor(name, height)} anlegen, und haben die Methode \inPy{rating} zur Verfügung. Vergleiche zwischen Instanzen von \inPy{ExpartnerWithEyeColor} oder sogar zwischen Instanzen von \inPy{ExpartnerWithEyeColor} und \inPy{Expartner} sind direkt möglich (denn unsere Vergleichsmethoden prüfen nicht den Datentyp ab, sondern verlangen nur, dass eine Methode \inPy{rating} existiert). Die Methode \inPy{__str__} dagegen wurde überschrieben, und listet nun auch die Augenfarbe mit auf.

\subsection{Methoden der Basisklasse -- super()}
Unsere Implementierung oben hat noch zwei kleine Schönheitsfehler:
\begin{itemize}
\item In der Methode \inPy{__init__} kann die Augenfarbe noch nicht mit angegeben werden.
\item Wenn wir die Methode \inPy{__str__} von \inPy{Expartner} ändern, müssen wir immer noch manuell diese Änderungen auch in \inPy{ExpartnerWithEyeColor} vornehmen.
\end{itemize}
Beide Methoden -- \inPy{__init__} und \inPy{__str__} -- sind sich in \inPy{Expartner} und \inPy{ExpartnerWithEyeColor} sehr ähnlich, aber nicht exakt identisch. Es wäre angenehm, wenn wir die Methoden der Basisklasse zur Konstruktion der abgeleiteten Klasse benutzen könnten -- und dies ist tatsächlich möglich!

In Klassenmethoden kann die Funktion \inPy{super()} aufgerufen werden. Diese gibt eine Instanz von \inPy{self} zurück, das aber als Instanz der Basisklasse interpretiert wird. Damit können wir unsere Klasse \inPy{ExpartnerWithEyeColor} auch schreiben als:

\begin{codebox}[Beispiel: Abeleitete Klasse mit Methoden der Basisklasse]
\begin{minted}[linenos]{python3}
# Klasse Expartner wie oben

class ExpartnerWithEyeColor(Expartner) :
    eyeColor = None
    
    def __init__(self, name = None, height = None, eyeColor = None
                 upsides = {}, downsides = {}) :
        super().__init__(name, height, upsides, downsides)
        self.eyeColor = eyeColor
        
    def __str__(self) :
        return super().__str__() + "\n  Eye Color   : " + str(self.eyeColor)

ex = ExpartnerWithEyeColor("Reginald", 1.84, "blue"
                          {"very intelligent", "handsome", "plays in a band"},
                          {"flirty with everyone", "complains a lot"})
print(ex)
\end{minted}
\end{codebox}
(Die Ausgabe bleibt hierbei unverändert.)

Betrachten wir zuerst Zeile 12: Hier behandeln wir also die aktuelle Klasseninstanz \inPy{self} als Instanz der \emph{Basisklasse} \inPy{ExpartnerWithEyeColor}  (durch das Element \inPy{super()}). Von dieser Instanz rufen wir die Methode \inPy{__str__} auf, und erhalten so bereits die ersten Zeilen unserer Zusammenfassung. An diese wird nun noch eine weitere Zeile angehängt, und ergänzt so die Textdarstellung von \inPy{ExpartnerWithEyeColor}.

Ähnlich lassen wir in Zeile 8 bereits alle Attribute ausfüllen, die schon in \inPy{Expartner} existiert haben. Insbesondere nutzen wir hier auch dieselbe Plausiblitätsprüfung: ExpartnerInnen mit negativer Körpergröße führen zu einer Fehlermeldung. Was danach noch übrig bleibt ist das Eintragen der Augenfarbe, was in Zeile 9 erledigt wird.


\subsection{Mehrfach-Vererbung}
Es ist auch möglich, dass eine Klasse von \emph{mehreren} Basisklassen erbt. Das Ergebnis ist eine Klasse, die die \emph{Summe} aller Methoden und Attribute der Basisklasse implementiert. Dabei darf es nicht zu Namenskollisionen kommen: Sowohl die Basisklasse \texttt{A} als auch die Basisklasse \texttt{B} eine Methode \texttt{M} besitzen, wird die abgeleitete Klasse \inPy{class X(A, B)} nur die Methode \texttt{M} von \texttt{A} übernehmen. Einzige Ausnahme: Die Methode \inPy{__init__} wird von allen Basisklassen übernommen; \inPy{super().__init__()} ruft die Konstruktoren von \emph{allen} Basisklassen in der Reihenfolge auf, in der sie bei der Definition der abgeleiteten Klasse genannt wurden.

Betrachten wir das folgende Klassendiagramm:
\begin{tcolorbox}[title=Klassendiagramm]
%
\tikzstyle{class}=[rectangle, draw=black, rounded corners, fill=blue!40!black,
        text centered, anchor=north, text=white, text width=4.5cm]
\tikzstyle{instance}=[rectangle, draw=black, rounded corners, fill=green!40!white,
        text centered, anchor=north, text=black, text width=4.5cm]
                
\tikzstyle{inherits}=[->, >=open triangle 90, thick]
\tikzstyle{instantiates}=[->, >=open diamond, thick]

\begin{tikzpicture}[node distance=1cm]
	\node (Animal) [class]                  {\texttt{Animal}};
	\node (Mammal) [class, below=of Animal] {\texttt{Mammal}};
	
	\node (AuxNode01) [          below=of Mammal   , text width=0.0cm] {};
	\node (AuxNode02) [          right=of Animal   , text width=0.5cm] {};
	\node (Klasse)    [class,    right=of AuxNode02, text width=3.0cm] {\texttt{Klasse}};
	\node (Instanz)   [instance, below=of Klasse   , text width=3.0cm] {\texttt{Instanz}};
	
	\node (NonWingedMammal) [class, left =of AuxNode01] {\texttt{NonWingedMammal}};
	\node (NonMarineMammal) [class, right=of AuxNode01] {\texttt{NonMarineMammal}};
	
	\node (Dog) [class, below=of AuxNode01] {\texttt{Dog}};
	
	\node (d)   [instance, below=of Dog] {\texttt{d}};
	\node (bat) [instance, right=of d]   {\texttt{bat}};
	
	\draw[inherits] (Mammal.north) -| (Animal.south);
	\draw[inherits] (NonWingedMammal.north) -- ++(0,0.36) -| (Mammal.south);
	\draw[inherits] (NonMarineMammal.north) -- ++(0,0.40) -| (Mammal.south);
	\draw[inherits] (Dog.north) -- ++(0,0.40) -| (NonMarineMammal.south);
	\draw[inherits] (Dog.north) -- ++(0,0.40) -| (NonWingedMammal.south);
	
	\draw[instantiates] (d.north)   -- ++(0,0.40) -| (Dog.south);
	\draw[instantiates] (bat.north) -- ++(0,1.20) -| ([xshift=0.8cm] NonMarineMammal.south);
\end{tikzpicture}
(Quelle: \url{https://www.programiz.com/python-programming/methods/built-in/super})
\end{tcolorbox}

dies lässt sich durch den folgenden Code umsetzen:

\begin{codebox}[Beispiel: Multi-Vererbung]
\begin{minted}[linenos]{python3}
class Animal :
  def __init__(self, Animal) :
    print(Animal, 'is an animal.')
    
class Mammal(Animal) :
  def __init__(self, mammalName) :
    print(mammalName, 
          'is a warm-blooded animal.')
    super().__init__(mammalName)

class NonWingedMammal(Mammal) :
  def __init__(self, NonWingedMammal) :
    print(NonWingedMammal, "can't fly.")
    super().__init__(NonWingedMammal)

class NonMarineMammal(Mammal) :
  def __init__(self, NonMarineMammal) :
    print(NonMarineMammal, 
          "can't swim.")
    super().__init__(NonMarineMammal)
\end{minted}
\end{codebox}
%
\begin{codebox}[]
\begin{minted}[linenos, firstnumber=last]{python3}
    
class Dog(NonMarineMammal,
          NonWingedMammal) :
  def __init__(self) :
    print('Dog has 4 legs.')
    super().__init__('Dog')

d = Dog()
print('')
bat = NonMarineMammal('Bat')
\end{minted}
\end{codebox}

und erzeugt die Ausgabe:

\begin{cmdbox}[Ausgabe: Multi-Vererbung]
\begin{minted}{text}
Dog has 4 legs.
Dog can't swim.
Dog can't fly.
Dog is a warm-blooded animal.
Dog is an animal.

Bat can't swim.
Bat is a warm-blooded animal.
Bat is an animal.
\end{minted}
\end{cmdbox}


\begin{hintbox}[Klassenbeziehungen einfach halten]
Die Technik \emph{Vererbung} ist zweifellos sehr nützlich, kann aber schnell unerwartete Nebeneffekte ansammeln. Über mehrere Ebenen hinweg geht der Überblick leicht verloren. Versuchen Sie daher nach Möglichkeit, abgeleitete Klassen nicht als Basisklasse anderer Klassen zu benutzen.

Auch von Mehrfach-Vererbung wird im Allgemeinen abgeraten. Zu bevorzugen sind einfachere Code-Strukturen mit weniger verschränkten Abhängigkeiten.
\end{hintbox}